# Generated by `rjournal_pdf_article()` using `knitr::purl()`: do not edit by hand
# Please edit paper-mapycusmaximus.Rmd to modify this file

## ----setup, include=FALSE-------------------------------------------------------
knitr::opts_chunk$set(echo = FALSE, warning = FALSE, message = FALSE)
library(tidyverse)
library(mapycusmaximus)
library(geogrid)
library(sf)
library(units)
library(ggthemes)
library(cowplot)
library(RColorBrewer)
library(cartogram)
library(patchwork)
library(ggrepel)
library(DiagrammeR)
library(rsvg)
library(DiagrammeRsvg)


## ----intro-snippet, eval=FALSE--------------------------------------------------
# # Minimal usage: warp an sf layer around a focal polygon
# melb <- vic |> dplyr::filter(LGA_NAME == "MELBOURNE")
# vic_fish <- sf_fisheye(vic, center = melb, r_in = 0.33, r_out = 0.60,
#                        zoom = 1.8, squeeze = 0.35)


## ----data-cart, include=FALSE---------------------------------------------------
# Library
# Load the population per states (source: https://www.census.gov/data/tables/2017/demo/popest/nation-total.html)
pop <- read.table("https://raw.githubusercontent.com/holtzy/R-graph-gallery/master/DATA/pop_US.csv", sep = ",", header = T)
pop$pop <- pop$pop / 1000000

# merge both
my_sf <- read_sf("https://andrew.carto.com/api/v2/sql?filename=us_states_hexgrid&q=select+*+from+andrew.us_states_hexgrid&format=geojson&bounds=&api_key=")
my_sf <- my_sf |>
  mutate(google_name = gsub(" \\(United States\\)", "", google_name))
my_sf <- my_sf |> left_join(pop, by = c("google_name" = "state"))

# Compute the cartogram, using this population information
# First we need to change the projection, we use Mercator (AKA Google Maps, EPSG 3857)
my_sf_merc <- st_transform(my_sf, 3857)
cartogram <- cartogram_cont(my_sf_merc, "pop")

# Back to original projection
cartogram <- st_transform(cartogram, st_crs(my_sf))


## ----plot-cart, echo=FALSE, fig.cap="Cartogram example: thematic distortion changes shapes and sizes to encode population."----
ggplot(cartogram) +
  geom_sf(aes(fill = pop), linewidth = 0.05, alpha = 0.9, color = "black") +
  scale_fill_gradientn(
    colours = brewer.pal(7, "BuPu"), name = "population (in M)",
    labels = scales::label_comma(),
    guide = guide_legend(
      keyheight = unit(3, units = "mm"),
      keywidth = unit(12, units = "mm"),
      title.position = "top",
      label.position = "bottom"
    )
  ) +
  geom_sf_text(aes(label = iso3166_2), color = "white", size = 3, alpha = 0.8) +
  theme_void() +
  ggtitle("Another look on the US population") +
  theme(
    legend.position = c(0.5, 0.9),
    legend.direction = "horizontal",
    text = element_text(color = "#22211d"),
    plot.background = element_rect(fill = "#f5f5f9", color = NA),
    panel.background = element_rect(fill = "#f5f5f9", color = NA),
    legend.background = element_rect(fill = "#f5f5f9", color = NA),
    plot.title = element_text(size = 22, hjust = 0.5, color = "#4e4d47", margin = margin(b = -0.1, t = 0.4, l = 2, unit = "cm")),
  )


## ----data-geo-grid, include=FALSE-----------------------------------------------

vic <- vic |> st_transform(3111)
vic <- vic |> 
 mutate(
  LGA_ABBR = case_when(
   LGA_NAME == "CARDINIA" ~ "CAR",
   LGA_NAME == "NILLUMBIK" ~ "NIL",
   LGA_NAME == "MITCHELL" ~ "MIT",
   LGA_NAME == "HUME" ~ "HUM",
   LGA_NAME == "MOIRA" ~ "MOI",
   LGA_NAME == "MURRINDINDI" ~ "MUR",
   LGA_NAME == "LODDON" ~ "LOD",
   LGA_NAME == "GLEN EIRA" ~ "GE",
   LGA_NAME == "GREATER SHEPPARTON" ~ "GS",
   LGA_NAME == "GANNAWARRA" ~ "GAN",
   LGA_NAME == "SURF COAST" ~ "SC",
   LGA_NAME == "WHITTLESEA" ~ "WHS",
   LGA_NAME == "MACEDON RANGES" ~ "MR",
   LGA_NAME == "GREATER DANDENONG" ~ "GD",
   LGA_NAME == "BAYSIDE" ~ "BAY",
   LGA_NAME == "MANSFIELD" ~ "MAN",
   LGA_NAME == "WEST WIMMERA" ~ "WW",
   LGA_NAME == "MILDURA" ~ "MIL",
   LGA_NAME == "HINDMARSH" ~ "HIN",
   LGA_NAME == "GOLDEN PLAINS" ~ "GP",
   LGA_NAME == "HORSHAM" ~ "HOR",
   LGA_NAME == "PYRENEES" ~ "PYR",
   LGA_NAME == "STRATHBOGIE" ~ "STR",
   LGA_NAME == "HOBSONS BAY" ~ "HB",
   LGA_NAME == "QUEENSCLIFFE" ~ "QUE",
   LGA_NAME == "SWAN HILL" ~ "SH",
   LGA_NAME == "MORNINGTON PENINSULA" ~ "MP",
   LGA_NAME == "SOUTH GIPPSLAND" ~ "SG",
   LGA_NAME == "SOUTHERN GRAMPIANS" ~ "SGR",
   LGA_NAME == "GLENELG" ~ "GLE",
   LGA_NAME == "CASEY" ~ "CAS",
   LGA_NAME == "KNOX" ~ "KNO",
   LGA_NAME == "NORTHERN GRAMPIANS" ~ "NG",
   LGA_NAME == "MONASH" ~ "MON",
   LGA_NAME == "BALLARAT" ~ "BAL",
   LGA_NAME == "MOONEE VALLEY" ~ "MV",
   LGA_NAME == "MERRI-BEK" ~ "MBK",
   LGA_NAME == "GREATER BENDIGO" ~ "GB",
   LGA_NAME == "CAMPASPE" ~ "CAM",
   LGA_NAME == "WARRNAMBOOL" ~ "WAR",
   LGA_NAME == "BASS COAST" ~ "BC",
   LGA_NAME == "ALPINE" ~ "ALP",
   LGA_NAME == "EAST GIPPSLAND" ~ "EG",
   LGA_NAME == "YARRIAMBIACK" ~ "YAK",
   LGA_NAME == "BULOKE" ~ "BUL",
   LGA_NAME == "TOWONG" ~ "TOW",
   LGA_NAME == "WODONGA" ~ "WOD",
   LGA_NAME == "INDIGO" ~ "IND",
   LGA_NAME == "HEPBURN" ~ "HEP",
   LGA_NAME == "WYNDHAM" ~ "WYN",
   LGA_NAME == "MOUNT ALEXANDER" ~ "MA",
   LGA_NAME == "CENTRAL GOLDFIELDS" ~ "CG",
   LGA_NAME == "WHITEHORSE" ~ "WH",
   LGA_NAME == "KINGSTON" ~ "KIN",
   LGA_NAME == "MARIBYRNONG" ~ "MAR",
   LGA_NAME == "ARARAT" ~ "ARA",
   LGA_NAME == "MOORABOOL" ~ "MOO",
   LGA_NAME == "WELLINGTON" ~ "WEL",
   LGA_NAME == "MAROONDAH" ~ "MARO",
   LGA_NAME == "DAREBIN" ~ "DAR",
   LGA_NAME == "MANNINGHAM" ~ "MANI",
   LGA_NAME == "BRIMBANK" ~ "BRI",
   LGA_NAME == "MELBOURNE" ~ "MEL",
   LGA_NAME == "BOROONDARA" ~ "BOR",
   LGA_NAME == "GREATER GEELONG" ~ "GEE",
   LGA_NAME == "STONNINGTON" ~ "STO",
   LGA_NAME == "BANYULE" ~ "BAN",
   LGA_NAME == "LATROBE" ~ "LAT",
   LGA_NAME == "YARRA" ~ "YAR",
   LGA_NAME == "WANGARATTA" ~ "WAN",
   LGA_NAME == "YARRA RANGES" ~ "YARAN",
   LGA_NAME == "PORT PHILLIP" ~ "PP",
   LGA_NAME == "MELTON" ~ "MELT",
   LGA_NAME == "COLAC OTWAY" ~ "CO",
   LGA_NAME == "CORANGAMITE" ~ "COR",
   LGA_NAME == "MOYNE" ~ "MOY",
   LGA_NAME == "FRANKSTON" ~ "FRA",
   LGA_NAME == "BENALLA" ~ "BEN",
   LGA_NAME == "BAW BAW" ~ "BB",
   # Alpine resorts / unincorporated islands
   grepl("ALPINE RESORT", LGA_NAME) ~ "AR",
   grepl("ISLAND", LGA_NAME) ~ "ISL",
   TRUE ~ NA_character_
  ),
  area_km2 = as.numeric(set_units(st_area(geometry), "km^2")))


original_shapes <- vic |> st_transform(27700)
new_cells_reg <- calculate_grid(shape = original_shapes, grid_type = "regular", seed = 3)
resultreg <- assign_polygons(original_shapes, new_cells_reg)


## ----geo-grid-plot, echo=FALSE, fig.cap="Victoria LGA grid assignment: tile maps abstract away precise geometry in favour of adjacency."----
ggplot(resultreg) +
 geom_sf(aes(fill = area_km2)) +
 geom_sf_label(aes(label = LGA_ABBR), size = 2) +
 scale_fill_viridis_c() +
 coord_sf() +
 theme_map()


## ----data-cow-plot, include=FALSE-----------------------------------------------
lga_inset <- vic[vic$LGA_NAME == "MELBOURNE", ]
main_map <- ggplot() +
 geom_sf(data = vic, fill = "lightgray", color = "white") +
 geom_sf(data = lga_inset, fill = "red", color = "red") + # Highlight the inset area
 theme_void() +
 labs(title = "Victoria")
inset_map <- ggplot() +
 geom_sf(data = lga_inset, fill = "lightblue", color = "darkblue") +
 theme_void() +
 labs(title = "Melbourne LGA")


## ----cow-plot-plot, echo=FALSE, fig.cap="Overview with inset: separates focus from context into distinct panels."----
final_map <- ggdraw() +
 draw_plot(main_map, x = 0, y = 0, width = 1, height = 1) + # Main map occupies the whole canvas
 draw_plot(inset_map, x = 0.7, y = 0.7, width = 0.25, height = 0.25) # Inset map position and size

print(final_map)


## ----preparing-data, include=FALSE----------------------------------------------

plot_fisheye_fgc <- function(original_coords, transformed_coords, 
  cx = 0, cy = 0, r_in = 0.34, r_out = 0.5) {

# Create data frames for plotting
  zones <- classify_zones(original_coords, cx, cy, r_in, r_out)

  original_df <- data.frame(
    x = original_coords[, 1],
    y = original_coords[, 2],
    zone = zones,
    type = "Original"
  )

  transformed_df <- data.frame(
    x = transformed_coords[, 1],
    y = transformed_coords[, 2], 
    zone = zones,
    type = "Transformed"
  )

  combined_df <- rbind(original_df, transformed_df)

  # Create the plot
  p <- ggplot(combined_df, aes(x = x, y = y, color = zone)) +
    geom_point(size = 1.5, alpha = 0.8) +
    scale_color_manual(values = c("focus" = "#c60000ff", 
      "glue" = "#a5a9e8ff", 
      "context" = "#FFCC00")) +
    facet_wrap(~type) +
    coord_fixed() +
    theme_minimal() +
    theme(
      panel.grid.minor = element_blank(),
      legend.title = element_blank()
    ) +
    labs(title = "Fisheye FGC Transformation",
    subtitle = paste("r_in =", r_in, ", r_out =", r_out))

  # Add zone boundary circles
  if (r_in > 0) {
    circle_in <- data.frame(
      x = cx + r_in * cos(seq(0, 2*pi, length.out = 100)),
      y = cy + r_in * sin(seq(0, 2*pi, length.out = 100))
    )
  p <- p + geom_path(data = circle_in, aes(x = x, y = y), 
    color = "red", linetype = "dashed", inherit.aes = FALSE)
  }

  circle_out <- data.frame(
    x = cx + r_out * cos(seq(0, 2*pi, length.out = 100)),
    y = cy + r_out * sin(seq(0, 2*pi, length.out = 100))
  )
  p <- p + geom_path(data = circle_out, aes(x = x, y = y), 
    color = "blue", linetype = "dashed", inherit.aes = FALSE)

    return(p)
}


## ----fgc-zones, echo=FALSE, fig.cap="The three zones of an FGC transformation. Points inside the focus (red) expand radially; points in the glue (blue) compress toward the focus boundary; context points (gold) remain fixed."----

grid <- create_test_grid()
grid_df <- as_tibble(grid)
transform <- fisheye_fgc(grid, cx = 0, cy = 0, r_in = 0.34, r_out = 0.5)
transform_df <- as_tibble(transform) |>
  dplyr::mutate(
    zone = attr(transform, "zones"),
    r_orig = attr(transform, "original_radius"),
    r_new  = attr(transform, "new_radius")
  )
arrows_df <- cbind(grid_df, transform_df)

ggplot() +
  # Draw arrows showing movement
  # Original points
  geom_point(
    data = grid_df, aes(x = x, y = y),
    size = 0.6, alpha = 0.7, color = "#8080e0ff"
  ) +
  # Transformed points
  geom_point(
    data = transform_df, aes(x = x_new, y = y_new, color = zone),
    size = 0.6, alpha = 0.7
  ) +
  scale_color_manual(values = c("focus" = "#c60000ff", 
  "glue" = "#070737ff", 
  "context" = "#FFCC00")) +
    geom_segment(
  data = arrows_df |>
    filter(
      zone != "context",
      sqrt((x_new - x)^2 + (y_new - y)^2) > 1e-6  # only draw if moved
    ),
  aes(x = x, y = y, xend = x_new, yend = y_new, color = zone),
  arrow = arrow(length = unit(0.02, "npc")),
  alpha = 0.6,
  size = 0.5
) +
  scale_color_manual(values = c("focus" = "#c60000ff", 
     "glue" = "#070737ff", 
     "context" = "#FFCC00")) +
  coord_equal() +
  theme_minimal(base_size = 14) +
  labs(title = "Fisheye Transformation: Point Movement", x = "x", y = "y")



## ----diagnostics-output, echo=TRUE----------------------------------------------
# Inspect diagnostics returned by fisheye_fgc()
head(transform_df[, c("x_new", "y_new", "zone", "r_orig", "r_new")])
table(transform_df$zone)


## ----radial-curve, fig.cap="Radial mapping r→r' across focus, glue, and context.", out.width="120%"----
r_in  <- 0.34
r_out <- 0.55

rad <- tibble::tibble(r = seq(0, 1, length.out = 400))
xy  <- cbind(rad$r, 0)
xy2 <- fisheye_fgc(xy, r_in = r_in, r_out = r_out,
                    zoom_factor = 3, squeeze_factor = 0.35,
                    method = "outward")
xy2 <- xy2 |>
  as_tibble() |>
  mutate(zone = attr(xy2, "zones"),
          r1   = attr(xy2, "original_radius"),
          r2   = attr(xy2, "new_radius"))

# Points on the curve closest to r_in and r_out (for targeted labels)
i_in  <- which.min(abs(xy2$r1 - r_in))
i_out <- which.min(abs(xy2$r1 - r_out))
pt_in  <- xy2[i_in,  c("r1", "r2")]
pt_out <- xy2[i_out, c("r1", "r2")]
i_maxF <- which.max(if_else(xy2$r1 <= r_in, xy2$r2, NA_real_))

ggplot(xy2, aes(r1, r2, color = zone)) +
  # Light zone shading by r (x-axis)
  annotate("rect", xmin = 0,     xmax = r_in,  ymin = -Inf, ymax = Inf,
            fill = "#c60000", alpha = 0.05) +
  annotate("rect", xmin = r_in,  xmax = r_out, ymin = -Inf, ymax = Inf,
            fill = "#6c8ae6", alpha = 0.05) +
  annotate("rect", xmin = r_out, xmax = 1,     ymin = -Inf, ymax = Inf,
            fill = "#ffb000", alpha = 0.05) +
  # Curve + references
  geom_line(size = 1.1) +
  geom_abline(intercept = 0, slope = 1, linetype = "dashed",
              color = "steelblue", alpha = 0.6) +
  geom_vline(xintercept = c(r_in, r_out), linetype = c("dashed", "dotted"),
              color = "grey40") +
  geom_hline(yintercept = c(r_in, r_out), linetype = c("dashed", "dotted"),
              color = "grey40") +
  annotate("label", x = r_in,  y = 0.05, label = "r_in",  angle = 90, vjust = -0.5) +
  annotate("label", x = r_out, y = 0.05, label = "r_out", angle = 90, vjust = -0.5) +
  annotate("label", y = r_in + 0.03,  x = 0.05, label = "r_in") +
  annotate("label", y = r_out  + 0.03, x = 0.05, label = "r_out") +
  annotate("label", x = 0.88, y = 0.88, label = "identity: r' = r",
            color = "steelblue", fill = "white") +
  # Arrows to the curve at r_in / r_out
  annotate(
    "curve",
    x = r_in + 0.07, y = r_in + 0.02,
    xend = pt_in$r1, yend = pt_in$r2,
    curvature = 0.2,
    arrow = arrow(type = "closed", length = unit(6, "pt"))
  ) +
  annotate("label", x = r_in + 0.08, y = r_in + 0.04, label = "expansion at r_in",
            color = "steelblue", fill = "white") +
  annotate(
    "curve",
    x = r_out - 0.12, y = r_out + 0.08,
    xend = pt_out$r1, yend = pt_out$r2,
    curvature = -0.2,
    arrow = arrow(type = "closed", length = unit(6, "pt"))
  ) +
  annotate("label", x = r_out - 0.13, y = r_out + 0.09, label = "compression at r_out",
            color = "steelblue", fill = "white") +
  # Arrow to the inner radius
  geom_point(aes(x = r1, y = r2), data = xy2[i_maxF, ], size = 1, color = "black") +
  annotate(
    "curve",
    x = r_in * 0.55, y = r_in * 0.40,
    xend = xy2$r1[i_maxF], yend = xy2$r2[i_maxF],
    curvature = 0.2,
    arrow = arrow(type = "closed", length = unit(4, "pt"))
  ) +
  annotate("label", x = r_in, y = r_in * 0.5,
            label = "shifted radius (expansion) in focus \n then flattened at r_in",
            color = "steelblue", fill = "white") +
  # Visual cue for flattening at r_in (horizontal tangent/cap)
  scale_color_manual(values = c(focus = "#c60000", glue = "#6c8ae6", context = "#ffb000"),
                      name = "Zone") +
  coord_fixed(xlim = c(0, 1), ylim = c(0, 1), ratio = 1) +
  labs(x = "r (original)", y = "r' (warped)") +
  theme_minimal(base_size = 10)


## ----norm-diagram, fig.cap="Diagram of the normalization step", eval=knitr::is_html_output(), fig.align="center", out.width="100%"----
# grViz("
# digraph fgc {
#   rankdir=TB; nodesep=0.25; ranksep=0.4;
#   node [shape=rect, style=rounded, fontsize=10, fontname=Helvetica, fillcolor='#f5f5f9', color='#4e4d47', style=filled];
#   edge [color='#4e79a7', arrowsize=.7];
# 
#   A [label='Input sf/sfc or matrix\\noptions: center, preserve_aspect, normalized_center'];
#   B [shape=diamond, label='Projected?', fillcolor='#eef3ff'];
#   C [label='Use layer CRS'];
#   D [label='Transform to projected CRS\\n(UTM / GDA2020)'];
#   E [label='BBox (xmin,xmax,ymin,ymax)'];
#   F [label='Compute mid + half-spans'];
#   G [shape=diamond, label='Preserve aspect?', fillcolor='#eef3ff'];
#   H [label='Use s=max(sx,sy)'];
#   I [label='Use sx,sy independently'];
#   J [shape=diamond, label='Resolve center', fillcolor='#eef3ff'];
#   K [label='sf/sfc → centroid'];
#   L [label='numeric + CRS → transform'];
#   M [label='numeric only → lon/lat heuristic'];
#   N [label='normalized_center → (mx,my)+center*scale'];
#   O [label='Normalize to unit space'];
#   P [label='Apply fisheye'];
#   Q [label='Denormalize'];
#   R [label='Restore CRS'];
# 
#   A -> B;
#   B -> C [label='yes'];
#   B -> D [label='no'];
#   C -> E;
#   D -> E;
#   E -> F;
#   F -> G;
#   G -> H [label='yes'];
#   G -> I [label='no'];
#   H -> J;
#   I -> J;
#   J -> K;
#   J -> L;
#   J -> M;
#   J -> N;
#   K -> O;
#   L -> O;
#   M -> O;
#   N -> O;
#   O -> P;
#   P -> Q;
#   Q -> R;
# }
# ")


## ----norm-diagram-pdf, fig.cap="Diagram of the normalization step", eval=knitr::is_latex_output(), fig.align="center", out.width="80%"----

# Static version for PDF using DiagrammeR's export

diagram <- grViz("
digraph fgc {
  rankdir=TB; nodesep=0.25; ranksep=0.4;
  node [shape=rect, style=rounded, fontsize=10, fontname=Helvetica, fillcolor='#f5f5f9', color='#4e4d47', style=filled];
  edge [color='#4e79a7', arrowsize=.7];

  A [label='Input sf/sfc or matrix\\noptions: center, preserve_aspect, normalized_center'];
  B [shape=diamond, label='Projected?', fillcolor='#eef3ff'];
  C [label='Use layer CRS'];
  D [label='Transform to projected CRS\\n(UTM / GDA2020)'];
  E [label='BBox (xmin,xmax,ymin,ymax)'];
  F [label='Compute mid + half-spans'];
  G [shape=diamond, label='Preserve aspect?', fillcolor='#eef3ff'];
  H [label='Use s=max(sx,sy)'];
  I [label='Use sx,sy independently'];
  J [shape=diamond, label='Resolve center', fillcolor='#eef3ff'];
  K [label='sf/sfc → centroid'];
  L [label='numeric + CRS → transform'];
  M [label='numeric only → lon/lat heuristic'];
  N [label='normalized_center → (mx,my)+center*scale'];
  O [label='Normalize to unit space'];
  P [label='Apply fisheye'];
  Q [label='Denormalize'];
  R [label='Restore CRS'];

  A -> B; 
  B -> C [label='yes']; 
  B -> D [label='no'];
  C -> E; 
  D -> E; 
  E -> F; 
  F -> G;
  G -> H [label='yes']; 
  G -> I [label='no'];
  H -> J; 
  I -> J;
  J -> K; 
  J -> L; 
  J -> M; 
  J -> N;
  K -> O; 
  L -> O; 
  M -> O; 
  N -> O;
  O -> P; 
  P -> Q; 
  Q -> R;
}
")

diagram |>
  export_svg() |>
  charToRaw() |>
  rsvg::rsvg_png("diagram.png")


## ----norm-diagram-gg, fig.cap="Diagram of the normalization step", eval=knitr::is_latex_output(), fig.align="center", out.width="80%"----
knitr::include_graphics("diagram.png")


## ----basic-example--------------------------------------------------------------
original <- create_test_grid()
fisheye_org <- fisheye_fgc(original, r_in = 0.34, r_out = 0.55)
plot_fisheye_fgc(original, fisheye_org)


## ----fisheye-attributes---------------------------------------------------------
fisheye_org |> head()
fisheye_org |> attributes() |> names()


## ----bench-data, eval=FALSE-----------------------------------------------------
# library(microbenchmark)
# 
# gen_xy <- function(n) matrix(runif(2L*n, -1, 1), ncol = 2)
# 
# bench_core <- function(ns = c(1e3, 2e3, 5e3, 1e4, 2e4, 5e4, 1e5), times = 10L) {
#   r_in <- 0.34; r_out <- 0.55
#   res <- lapply(ns, function(n) {
#     xy <- gen_xy(n)
#     invisible(fisheye_fgc(xy, r_in = r_in, r_out = r_out, zoom_factor = 1.6, squeeze_factor = 0.35)) # warm-up
#     b <- microbenchmark(
#       fisheye_fgc(xy, r_in = r_in, r_out = r_out, zoom_factor = 1.6, squeeze_factor = 0.35),
#       times = times, unit = "ms"
#     )
#     data.frame(
#       n = n,
#       median_ms = median(b$time),
#       per_vertex_ns = 1e6 * median(b$time) / n
#     )
#   })
#   df <- bind_rows(res) |>
#     mutate(logn = log(n), logt = log(median_ms))
#   slope <- coef(lm(logt ~ logn, data = df))[2]
#   list(data = df, slope = slope)
# }
# 
# core <- bench_core()
# 
# # sf_fisheye end-to-end (vertex-count scaling)
# 
# library(sf)
# 
# nverts <- function(sfc_or_sf) nrow(sf::st_coordinates(sfc_or_sf))
# 
# gen_points_sf <- function(n, crs = 3857) {
#   st_as_sf(data.frame(x = runif(n, -1, 1)*1e4, y = runif(n, -1, 1)*1e4),
#             coords = c("x", "y"), crs = crs)
# }
# 
# bench_sf <- function(ns = c(5e3, 1e4, 2e4, 5e4), times = 5L) {
#   res <- lapply(ns, function(n) {
#     s <- gen_points_sf(n)
#     center <- st_centroid(st_union(s))
#     invisible(sf_fisheye(s, center = center, r_in = 0.35, r_out = 0.60, zoom = 1.8, squeeze = 0.35)) # warm-up
#     b <- microbenchmark(
#       sf_fisheye(s, center = center, r_in = 0.35, r_out = 0.60, zoom = 1.8, squeeze = 0.35),
#       times = times, unit = "ms"
#     )
#     data.frame(
#       vertices = nverts(s),
#       median_ms = median(b$time),
#       per_vertex_ns = 1e6 * median(b$time) / nverts(s)
#     )
#   })
#   df <- bind_rows(res) |>
#     mutate(logv = log(vertices), logt = log(median_ms))
#   slope <- coef(lm(logt ~ logv, data = df))[2]
#   list(data = df, slope = slope)
# }
# 
# sfb <- bench_sf()
# sf_data <- sfb$data
# plot_1 <- ggplot(sf_data, aes(vertices, median_ms)) +
#   geom_point() + geom_line() +
#   scale_x_log10() + scale_y_log10() +
#   geom_smooth(method = "lm", se = FALSE) +
#   coord_fixed(ratio = 1)
# 
# 
# plot_2 <- ggplot(core$data, aes(n, median_ms)) +
#   geom_point() + geom_line() +
#   scale_x_log10() + scale_y_log10() +
#   geom_smooth(method = "lm", se = FALSE)+
#   coord_fixed(ratio = 1)
# 
# plot_all <- plot_1 + plot_2
# 
# save(plot_all, file = "data/plot-all.rda")
# 


## ----bench-plot, fig.cap="Benchmark performance of fisheye_fgc() and sf_fisheye()", echo=FALSE----
load("data/plot-all.rda")

plot_1 + plot_2


## ----transformation-table, echo=FALSE-------------------------------------------
# Table 1: Coordinate transformation across zones for selected points
samples <- transform_df |>
  group_by(zone) |>
  slice_head(n = 3) |> 
  ungroup()
idx <- as.numeric(rownames(samples))

orig_samples <- grid_df |>
  slice(idx)

samples <- samples |>
  cbind(orig_samples) |>
  select(x, y, x_new, y_new, zone, r_orig, r_new)

samples |>
  knitr::kable(
    caption = "Coordinate transformation across fisheye zones for selected points on a regular grid",
    digits = 3
  )


## ----multi-layer-example, eval=FALSE, echo=TRUE, fig.cap="Example of multi-layer fisheye transformation.", fig.align="center"----
# # Multi-layer example
# bind <- dplyr::bind_rows(
#   object_1 |> dplyr::mutate(.layer="object_1"),
#   object_2 |> dplyr::mutate(.layer="object_2"))
# 
# bind_w <- sf_fisheye(
#   bind,
#   center = melb,
#   r_in = 0.34,
#   r_out = 0.55,
#   zoom = 1.8,
#   squeeze = 0.35)
# 
# object_1_transformed   <- bind_w |>
#   dplyr::filter(.layer == "object_1") |>
#   dplyr::select(-.layer)
# 
# object_2_transformed   <- bind_w |>
#   dplyr::filter(.layer == "object_2") |>
#   dplyr::select(-.layer)


## -------------------------------------------------------------------------------
vic_fish_1 <- sf_fisheye(vic, center = melbourne, r_in = 0.35, r_out = 0.70, zoom_factor = 5)
vic_fish_2 <- sf_fisheye(vic, center = melbourne, r_in = 0.35, r_out = 0.70, zoom_factor = 20, squeeze_factor = 0.40)

plot_3 <- ggplot() + 
  geom_sf(data = vic_fish_1, fill = "grey", linewidth = 0.5) +
  geom_sf(data = vic_fish_1 |> filter(LGA_NAME == "MELBOURNE"), fill = "red", linewidth = 0.5, inherit.aes = FALSE) +
  labs(title = "Victoria map with center Melbourne \n zoom factor: 5") +
  theme(
  plot.title = element_text(size = 8) 
  ) +
  theme_map()

plot_4 <- ggplot() + 
  geom_sf(data = vic_fish_2, fill = "grey", linewidth = 0.5) +
  geom_sf(data = vic_fish_2 |> filter(LGA_NAME == "MELBOURNE"), fill = "red", linewidth = 0.5, inherit.aes = FALSE) +
  labs(title = "Victoria map with center Melbourne \n zoom factor: 20") +
  geom_sf_label(data = melbourne, aes(label = "Mel CBD"), size = 3) +
  theme(
  plot.title = element_text(size = 8) 
  ) +
  theme_map()

plot_3 + plot_4


## ----method-plot, echo=FALSE, fig.cap="Different method for glue compression"----
vic_fish_3 <- sf_fisheye(vic, center = melbourne, r_in = 0.3, r_out = 0.4, zoom_factor = 15, squeeze_factor = 0.7, method = "outward")
vic_fish_4 <- sf_fisheye(vic, center = melbourne, r_in = 0.3, r_out = 0.4, zoom_factor = 15, squeeze_factor = 0.7, method = "expand")

plot_5 <- ggplot() + 
  geom_sf(data = vic_fish_3, fill = "grey", linewidth = 0.5) +
  geom_sf(data = vic_fish_3 |> filter(LGA_NAME == "MELBOURNE"), fill = "red", linewidth = 0.5, inherit.aes = FALSE) +
  labs(title = "Method: Outward") +
  theme(
  plot.title = element_text(size = 8) 
  ) +
  theme_map()

plot_6 <- ggplot() + 
  geom_sf(data = vic_fish_4, fill = "grey", linewidth = 0.5) +
  geom_sf(data = vic_fish_4 |> filter(LGA_NAME == "MELBOURNE"), fill = "red", linewidth = 0.5, inherit.aes = FALSE) +
  labs(title = "Method: Expand") +
  theme(
  plot.title = element_text(size = 8) 
  ) +
  theme_map()

plot_5 + plot_6



## ----radii-prepare--------------------------------------------------------------
vic_fish_1 <- sf_fisheye(vic, center = melbourne, r_in = 0.1, r_out = 0.2, zoom_factor = 5)
vic_fish_2 <- sf_fisheye(vic, center = melbourne, r_in = 0.25, r_out = 0.3, zoom_factor = 5)
vic_fish_3 <- sf_fisheye(vic, center = melbourne, r_in = 0.35, r_out = 0.5, zoom_factor = 5)
vic_fish_4 <- sf_fisheye(vic, center = melbourne, r_in = 0.5, r_out = 0.70, zoom_factor = 5)


plot_test_1 <- ggplot() +
  geom_sf(data = vic_fish_1, fill = "grey", linewidth = 0.5) +
  geom_sf(data = vic_fish_1 |> filter(LGA_NAME == "MELBOURNE"), fill = "red", linewidth = 0.5, inherit.aes = FALSE) +
  labs(title = "Radii: 0.1, 0.2") +
  theme_map()

plot_test_2 <- ggplot() +
  geom_sf(data = vic_fish_2, fill = "grey", linewidth = 0.5) +
  geom_sf(data = vic_fish_2 |> filter(LGA_NAME == "MELBOURNE"), fill = "red", linewidth = 0.5, inherit.aes = FALSE) +
  labs(title = "Radii: 0.25, 0.3") +
  theme_map()

plot_test_3 <- ggplot() +
  geom_sf(data = vic_fish_3, fill = "grey", linewidth = 0.5) +
  geom_sf(data = vic_fish_3 |> filter(LGA_NAME == "MELBOURNE"), fill = "red", linewidth = 0.5, inherit.aes = FALSE) +
  labs(title = "Radii: 0.35, 0.5") +
  theme_map()

plot_test_4 <- ggplot() +
  geom_sf(data = vic_fish_4, fill = "grey", linewidth = 0.5) +
  geom_sf(data = vic_fish_4 |> filter(LGA_NAME == "MELBOURNE"), fill = "red", linewidth = 0.5, inherit.aes = FALSE) +
  labs(title = "Radii: 0.5, 0.7") +
  theme_map()

plot_test_1 + plot_test_2 + plot_test_3 + plot_test_4


## ----fisheye-revolution, echo=FALSE, fig.cap="Fisheye with different revolutions.", fig.align="center"----
vic_fish_1 <- sf_fisheye(vic, center = melbourne, r_in = 0.35, r_out = 0.5, zoom_factor = 20, revolution = 0)
vic_fish_2 <- sf_fisheye(vic, center = melbourne, r_in = 0.35, r_out = 0.5, zoom_factor = 20, revolution = pi/2)

plot_test_1 <- ggplot() +
  geom_sf(data = vic_fish_1, fill = "grey", linewidth = 0.5) +
  geom_sf(data = vic_fish_1 |> filter(LGA_NAME == "MELBOURNE"), fill = "red", linewidth = 0.5, inherit.aes = FALSE) +
  labs(title = "Revolution: 0") +
  theme_map()

plot_test_2 <- ggplot() +
  geom_sf(data = vic_fish_2, fill = "grey", linewidth = 0.5) +
  geom_sf(data = vic_fish_2 |> filter(LGA_NAME == "MELBOURNE"), fill = "red", linewidth = 0.5, inherit.aes = FALSE) +
  labs(title = "Revolution: pi/2") +
  theme_map()

plot_test_1 + plot_test_2



## ----preparing-hosp-data--------------------------------------------------------
hosp_point <- conn_fish |>
  st_drop_geometry() |>
  select(destination, long_hosp, lat_hosp) |>
  distinct() |>
  st_as_sf(coords = c("long_hosp", "lat_hosp"), crs = 4326) |>
  st_transform(crs = st_crs(vic))

racf_point <- conn_fish |>
  st_drop_geometry() |>
  select(source, long_racf, lat_racf) |>
  distinct() |>
  st_as_sf(coords = c("long_racf", "lat_racf"), crs = 4326) |>
  st_transform(crs = st_crs(vic))


## ----hospitals-basic-plot, fig.cap="Standard maps: hospital (red) and RACF (blue) points plotted over Victoria without fisheye."----
# Standard plot
plot_hosp <- ggplot(vic) + 
  geom_sf(fill = "grey90") +
  geom_sf(data = hosp_point, color = "red", size = 0.3, alpha = 1) +
  ggtitle("Standard: Melbourne hospitals") +
  theme(
  plot.title = element_text(size = 8) # adjust here
  ) +
  theme_map() 
plot_racf <- ggplot(vic) + 
  geom_sf(fill = "grey90") +
  geom_sf(data = racf_point, color = "blue", size = 0.3, alpha = 1) +
  ggtitle("Standard: Melbourne RACFs") +
  theme(
  plot.title = element_text(size = 8) # adjust here
  ) +
  theme_map()

plot_hosp + plot_racf


## ----fisheye-preparation--------------------------------------------------------
melbourne <- vic_fish |> filter(LGA_NAME == "MELBOURNE")
hosp_point2 <- hosp_point |>
  mutate(type = "hospital") |>
  rename(id = destination)

racf_point2 <- racf_point |>
  mutate(type = "racf") |>
  rename(id = source)

all_points <- bind_rows(hosp_point2, racf_point2)

bind <- dplyr::bind_rows(vic |> dplyr::mutate(.layer="vic"), all_points |> dplyr::mutate(.layer="pts"))
bind_w <- sf_fisheye(bind, center = melbourne, r_in = 0.34, r_out = 0.55, zoom = 20, squeeze = 0.35)
vic_w   <- bind_w |> dplyr::filter(.layer == "vic") |> dplyr::select(-.layer)
pts_w   <- bind_w |> dplyr::filter(.layer == "pts") |> dplyr::select(-.layer)


## ----fisheye-plot, fig.cap="Fisheye applied with a common centre and parameters keeps overlays aligned while magnifying the Melbourne LGA."----
ggplot() +
  geom_sf(data = vic_w, fill = "grey", linewidth = 0.5) +
  geom_sf(data = vic_w |> filter(LGA_NAME == "MELBOURNE"), fill = "white", linewidth = 1) +
  geom_sf_label(data = melbourne, aes(label = "Mel CBD"), size = 3) +
  geom_sf(data = pts_w, aes(color = type), size = 1, alpha = 0.5) +
  scale_color_manual(
  name = "Facility type",
  values = c("hospital" = "red", "racf" = "blue"),
  labels = c("Hospital", "RACF")) +
  ggtitle("Melbourne hospitals and RACFs locations") +
  theme_map()


## ----france-preparation---------------------------------------------------------
map<-sf::read_sf('https://github.com/BjnNowak/lego_map/raw/main/data/france_sport.gpkg')

# Create classes
clean <- map |>
  mutate(clss=case_when(
    value<18~"1",
    value<20~"2",
    value<22~"3",
    value<24~"4",
    value<26~"5",
    TRUE~"6"
  ))

# Set color palette
pal <- c("#bb3e03","#ee9b00","#e9d8a6","#94d2bd","#0a9396","#005f73")
# Set color background
bck <- "#001219"

# Set theme 
theme_custom <- theme_void()+
  theme(
    plot.title = element_text(size = 14, face = "bold", hjust = 0.5, color = "#ffffffff"),
    plot.margin = margin(1,1,10,1,"pt"),
    plot.background = element_rect(fill=bck,color=NA),
    legend.position = "bottom",
    legend.title = element_text(hjust=0.5,color="white",face="bold"),
    legend.text = element_text(color="white")
  )

# Make grid
grd <- st_make_grid(
    clean, # map name 
    n = c(60,60) # number of cells per longitude/latitude
  )|>
  # convert back to sf object
  st_sf()|>
  # add a unique id to each cell 
  # (will be useful later to get back centroids data)
  mutate(id=row_number())
  
# Extract centroids
cent<-grd|>
  st_centroid()

# Intersect centroids with basemap
cent_clean<-cent|>
  st_intersection(clean)

# Make a centroid without geom
# (convert from sf object to tibble)
cent_no_geom <- cent_clean|>
  st_drop_geometry()

# Join with grid thanks to id column
grd_clean<-grd|>
  #filter(id%in%sel)|>
  left_join(cent_no_geom)

grd_clean <- grd_clean |> rename("geometry" = "st_make_grid.clean..n...c.60..60..")
cent_clean <- cent_clean |> rename("geometry" = "st_make_grid.clean..n...c.60..60..")

grd_clean_fish <- sf_fisheye(grd_clean)
cent_clean_fish <- sf_fisheye(cent_clean)



## ----france-plots---------------------------------------------------------------
plot_frc_1 <- ggplot() +
  geom_sf(
    grd_clean |> drop_na(),
    mapping = aes(geometry = geometry, fill = clss)
  ) +
  geom_sf(
    cent_clean,
    mapping = aes(geometry = geometry),
    fill = NA, pch = 21, size = 0.5
  ) +
  labs(title = "Before fisheye",
    fill="Percentage of population \nis a member of a sport association") +
  scale_fill_manual(
    values = pal,
    label = c("< 18 %","< 20 %","< 22 %","< 24 %","< 26 %", "≥ 26 %")
  ) +
  guides(
    fill = guide_legend(
      nrow = 1,
      title.position = "top",
      label.position = "bottom"
    )
  ) +
  theme_custom


plot_frc_2 <- ggplot() +
  geom_sf(
    grd_clean_fish |> drop_na(),
    mapping = aes(geometry = geometry, fill = clss)
  ) +
  geom_sf(
    cent_clean_fish,
    mapping = aes(geometry = geometry),
    fill = NA, pch = 21, size = 0.5
  ) +
  guides(
    fill = guide_legend(
      nrow = 1,
      title.position = "top",
      label.position = "bottom"
    )
  ) +
  labs(title = "After fisheye",
    fill="Percentage of population \nis a member of a sport association") +

  scale_fill_manual(
    values = pal,
    label = c("< 18 %","< 20 %","< 22 %","< 24 %","< 26 %", "≥ 26 %")
  ) +
  theme_custom


## ----france-comparison, fig.cap="France choropleth before (left) and after (right) fisheye: the lens improves legibility around the selected metropolitan area while preserving national context."----
plot_frc_1 + plot_frc_2

