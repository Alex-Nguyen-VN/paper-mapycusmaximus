<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.43">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Thanh Cuong Nguyen">
<meta name="author" content="Michael Lydeamore">
<meta name="author" content="Dianne Cook">
<meta name="dcterms.date" content="2025-10-30">

<title>Focus-Glue-Context Fisheye Transformations for Spatial Visualization</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
  margin-bottom: 0em;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>


<script src="paper-mapycusmaximus_files/libs/clipboard/clipboard.min.js"></script>
<script src="paper-mapycusmaximus_files/libs/quarto-html/quarto.js"></script>
<script src="paper-mapycusmaximus_files/libs/quarto-html/popper.min.js"></script>
<script src="paper-mapycusmaximus_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="paper-mapycusmaximus_files/libs/quarto-html/anchor.min.js"></script>
<link href="paper-mapycusmaximus_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="paper-mapycusmaximus_files/libs/quarto-html/quarto-syntax-highlighting-d4d76bf8491c20bad77d141916dc28e1.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="paper-mapycusmaximus_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="paper-mapycusmaximus_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="paper-mapycusmaximus_files/libs/bootstrap/bootstrap-1bc8a17f135ab3d594c857e9f48e611b.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<link href="paper-mapycusmaximus_files/libs/htmltools-fill-0.5.8.1/fill.css" rel="stylesheet">

<script src="paper-mapycusmaximus_files/libs/htmlwidgets-1.6.4/htmlwidgets.js"></script>

<script src="paper-mapycusmaximus_files/libs/viz-1.8.2/viz.js"></script>

<link href="paper-mapycusmaximus_files/libs/DiagrammeR-styles-0.2/styles.css" rel="stylesheet">

<script src="paper-mapycusmaximus_files/libs/grViz-binding-1.0.11/grViz.js"></script>

<meta name="quarto:status" content="draft">

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="fullcontent"><div id="quarto-draft-alert" class="alert alert-warning"><i class="bi bi-pencil-square"></i>Draft</div>

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Focus-Glue-Context Fisheye Transformations for Spatial Visualization</h1>
</div>


<div class="quarto-title-meta-author">
  <div class="quarto-title-meta-heading">Authors</div>
  <div class="quarto-title-meta-heading">Affiliation</div>
  
    <div class="quarto-title-meta-contents">
    <p class="author"><a href="https://alex-nguyen-vn.github.io">Thanh Cuong Nguyen</a> <a href="mailto:thanhcuong10091992@gmail.com" class="quarto-title-author-email"><i class="bi bi-envelope"></i></a> <a href="https://orcid.org/0000-0000-0000-0000" class="quarto-title-author-orcid"> <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAA2ZpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMC1jMDYwIDYxLjEzNDc3NywgMjAxMC8wMi8xMi0xNzozMjowMCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDo1N0NEMjA4MDI1MjA2ODExOTk0QzkzNTEzRjZEQTg1NyIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDozM0NDOEJGNEZGNTcxMUUxODdBOEVCODg2RjdCQ0QwOSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDozM0NDOEJGM0ZGNTcxMUUxODdBOEVCODg2RjdCQ0QwOSIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ1M1IE1hY2ludG9zaCI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOkZDN0YxMTc0MDcyMDY4MTE5NUZFRDc5MUM2MUUwNEREIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjU3Q0QyMDgwMjUyMDY4MTE5OTRDOTM1MTNGNkRBODU3Ii8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+84NovQAAAR1JREFUeNpiZEADy85ZJgCpeCB2QJM6AMQLo4yOL0AWZETSqACk1gOxAQN+cAGIA4EGPQBxmJA0nwdpjjQ8xqArmczw5tMHXAaALDgP1QMxAGqzAAPxQACqh4ER6uf5MBlkm0X4EGayMfMw/Pr7Bd2gRBZogMFBrv01hisv5jLsv9nLAPIOMnjy8RDDyYctyAbFM2EJbRQw+aAWw/LzVgx7b+cwCHKqMhjJFCBLOzAR6+lXX84xnHjYyqAo5IUizkRCwIENQQckGSDGY4TVgAPEaraQr2a4/24bSuoExcJCfAEJihXkWDj3ZAKy9EJGaEo8T0QSxkjSwORsCAuDQCD+QILmD1A9kECEZgxDaEZhICIzGcIyEyOl2RkgwAAhkmC+eAm0TAAAAABJRU5ErkJggg=="></a></p>
  </div>
  <div class="quarto-title-meta-contents">
        <p class="affiliation">
            Monash University
          </p>
      </div>
    <div class="quarto-title-meta-contents">
    <p class="author"><a href="https://www.michaellydeamore.com">Michael Lydeamore</a> <a href="mailto:michael.lydeamore@monash.edu" class="quarto-title-author-email"><i class="bi bi-envelope"></i></a> <a href="https://orcid.org/0000-0001-6515-827X" class="quarto-title-author-orcid"> <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAA2ZpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMC1jMDYwIDYxLjEzNDc3NywgMjAxMC8wMi8xMi0xNzozMjowMCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDo1N0NEMjA4MDI1MjA2ODExOTk0QzkzNTEzRjZEQTg1NyIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDozM0NDOEJGNEZGNTcxMUUxODdBOEVCODg2RjdCQ0QwOSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDozM0NDOEJGM0ZGNTcxMUUxODdBOEVCODg2RjdCQ0QwOSIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ1M1IE1hY2ludG9zaCI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOkZDN0YxMTc0MDcyMDY4MTE5NUZFRDc5MUM2MUUwNEREIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjU3Q0QyMDgwMjUyMDY4MTE5OTRDOTM1MTNGNkRBODU3Ii8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+84NovQAAAR1JREFUeNpiZEADy85ZJgCpeCB2QJM6AMQLo4yOL0AWZETSqACk1gOxAQN+cAGIA4EGPQBxmJA0nwdpjjQ8xqArmczw5tMHXAaALDgP1QMxAGqzAAPxQACqh4ER6uf5MBlkm0X4EGayMfMw/Pr7Bd2gRBZogMFBrv01hisv5jLsv9nLAPIOMnjy8RDDyYctyAbFM2EJbRQw+aAWw/LzVgx7b+cwCHKqMhjJFCBLOzAR6+lXX84xnHjYyqAo5IUizkRCwIENQQckGSDGY4TVgAPEaraQr2a4/24bSuoExcJCfAEJihXkWDj3ZAKy9EJGaEo8T0QSxkjSwORsCAuDQCD+QILmD1A9kECEZgxDaEZhICIzGcIyEyOl2RkgwAAhkmC+eAm0TAAAAABJRU5ErkJggg=="></a></p>
  </div>
  <div class="quarto-title-meta-contents">
        <p class="affiliation">
            Monash University
          </p>
      </div>
    <div class="quarto-title-meta-contents">
    <p class="author"><a href="https://www.dicook.org">Dianne Cook</a> <a href="mailto:dicook@monash.edu" class="quarto-title-author-email"><i class="bi bi-envelope"></i></a> <a href="https://orcid.org/0000-0002-3813-7155" class="quarto-title-author-orcid"> <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAA2ZpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMC1jMDYwIDYxLjEzNDc3NywgMjAxMC8wMi8xMi0xNzozMjowMCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDo1N0NEMjA4MDI1MjA2ODExOTk0QzkzNTEzRjZEQTg1NyIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDozM0NDOEJGNEZGNTcxMUUxODdBOEVCODg2RjdCQ0QwOSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDozM0NDOEJGM0ZGNTcxMUUxODdBOEVCODg2RjdCQ0QwOSIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ1M1IE1hY2ludG9zaCI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOkZDN0YxMTc0MDcyMDY4MTE5NUZFRDc5MUM2MUUwNEREIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjU3Q0QyMDgwMjUyMDY4MTE5OTRDOTM1MTNGNkRBODU3Ii8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+84NovQAAAR1JREFUeNpiZEADy85ZJgCpeCB2QJM6AMQLo4yOL0AWZETSqACk1gOxAQN+cAGIA4EGPQBxmJA0nwdpjjQ8xqArmczw5tMHXAaALDgP1QMxAGqzAAPxQACqh4ER6uf5MBlkm0X4EGayMfMw/Pr7Bd2gRBZogMFBrv01hisv5jLsv9nLAPIOMnjy8RDDyYctyAbFM2EJbRQw+aAWw/LzVgx7b+cwCHKqMhjJFCBLOzAR6+lXX84xnHjYyqAo5IUizkRCwIENQQckGSDGY4TVgAPEaraQr2a4/24bSuoExcJCfAEJihXkWDj3ZAKy9EJGaEo8T0QSxkjSwORsCAuDQCD+QILmD1A9kECEZgxDaEZhICIzGcIyEyOl2RkgwAAhkmC+eAm0TAAAAABJRU5ErkJggg=="></a></p>
  </div>
  <div class="quarto-title-meta-contents">
        <p class="affiliation">
            Monash University
          </p>
      </div>
  </div>

<div class="quarto-title-meta">

      
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">October 30, 2025</p>
    </div>
  </div>
  
    
  </div>
  
<div>
  <div class="abstract">
    <div class="block-title">Abstract</div>
    <p>Fisheye views magnify local detail while preserving context, yet projection-aware, scriptable tools for R spatial analysis remain limited. mapycusmaximus introduces a Focus–Glue–Context (FGC) fisheye transform for numeric coordinates and sf geometries. Acting radially around a chosen center, the transform defines a magnified focus (r_in), a smooth transitional glue zone (r_out), and a fixed exterior. Distances expand or compress via a zoom factor and a power-law squeeze, with an optional angular twist that enhances continuity. The method is projection-conscious: lon/lat inputs are reprojected to suitable CRSs (e.g., GDA2020/MGA55), normalized for stable parameter control, and restored afterward. A geometry-safe engine (st_transform_custom) supports all feature types, maintaining ring closure and metadata. The high-level sf_fisheye() integrates with tidyverse, ggplot2, and Shiny, with built-in datasets and tests ensuring reproducibility. By coupling coherent radial warps with tidy, CRS-aware workflows, mapycusmaximus enables spatial exploration that emphasizes local structure without losing global context.</p>
  </div>
</div>


</header>


<section id="introduction" class="level1">
<h1>Introduction</h1>
<p>Maps that reveal fine local structure without losing broader context face a persistent challenge: zooming in hides regional patterns, while small-scale views suppress local detail. Traditional solutions—insets, multi-panel displays, aggressive generalization—break spatial continuity and increase cognitive load <span class="citation" data-cites="cockburn2008">(<a href="#ref-cockburn2008" role="doc-biblioref">Cockburn, Karlson, and Bederson 2008</a>)</span>. What if we could smoothly magnify a metropolitan core <em>while keeping it embedded</em> in its state-level context?</p>
<p>This package implements a Focus–Glue–Context (FGC) fisheye transformation that continuously warps geographic space. The transformation magnifies a chosen focus region, compresses surrounding areas into a transitional glue zone, and maintains stability in the outer context. The approach operates directly on vector geometry coordinates, preserves topology, and supports reproducible, pipeline‑oriented cartography within the R sf and ggplot2 ecosystem. An optional glue‑zone twist (the <code>revolution</code> parameter) can gently rotate features to aid continuity; in this paper’s figures we set <code>revolution = 0</code>.</p>
<p>The intellectual lineage of focus+context visualization traces back to <span class="citation" data-cites="furnas1986">Furnas (<a href="#ref-furnas1986" role="doc-biblioref">1986</a>)</span>’s <em>degree-of-interest</em> function, which introduced a formal method to rank information elements by combining intrinsic importance with distance from the user’s focus. In this model, items with low DOI are deemphasized or hidden, enabling emphasis on salient regions without losing global structure. <span class="citation" data-cites="sarkar1992">Sarkar and Brown (<a href="#ref-sarkar1992" role="doc-biblioref">1992</a>)</span> and <span class="citation" data-cites="sarkar1994">Sarkar and Brown (<a href="#ref-sarkar1994" role="doc-biblioref">1994</a>)</span> extended this to geometric distortion, demonstrating smooth magnification transitions for graph visualization. Subsequent innovations explored diverse lenses: hyperbolic geometry for hierarchies <span class="citation" data-cites="lamping1995">(<a href="#ref-lamping1995" role="doc-biblioref">Lamping, Rao, and Pirolli 1995</a>)</span>, distortion-view frameworks <span class="citation" data-cites="carpendale2001">(<a href="#ref-carpendale2001" role="doc-biblioref">Carpendale and Montagnese 2001</a>)</span>, and “magic lens” overlays <span class="citation" data-cites="bier1993">(<a href="#ref-bier1993" role="doc-biblioref">Bier et al. 1993</a>)</span>. By 2008, <span class="citation" data-cites="cockburn2008">Cockburn, Karlson, and Bederson (<a href="#ref-cockburn2008" role="doc-biblioref">2008</a>)</span>’s comprehensive review synthesized two decades of research across overview+detail, zooming, and focus+context paradigms.</p>
<p>In cartography, the need for nonlinear magnification emerged independently. <span class="citation" data-cites="snyder1987">Snyder (<a href="#ref-snyder1987" role="doc-biblioref">1987</a>)</span> developed “magnifying-glass” azimuthal projections with variable radial scales—mathematical foundations. <span class="citation" data-cites="harrie2002">Harrie, Sarjakoski, and Lehto (<a href="#ref-harrie2002" role="doc-biblioref">2002</a>)</span> created variable-scale functions for mobile devices where user position appears large-scale against small-scale surroundings. An influential contribution came from <span class="citation" data-cites="yamamoto2009">Yamamoto, Ozeki, and Takahashi (<a href="#ref-yamamoto2009" role="doc-biblioref">2009</a>)</span> and <span class="citation" data-cites="yamamoto2012">Yamamoto et al. (<a href="#ref-yamamoto2012" role="doc-biblioref">2012</a>)</span>: their <strong>Focus+Glue+Context model</strong> introduced an intermediate “glue” region that absorbs distortion, preventing the excessively warped roads and boundaries that plagued earlier fisheye maps. This three-zone architecture proved particularly effective for pedestrian navigation and mobile web services.</p>
<p>Within R’s spatial ecosystem, sf <span class="citation" data-cites="RJ-2018-009">(<a href="#ref-RJ-2018-009" role="doc-biblioref">Pebesma 2018</a>)</span> provides robust vector handling and CRS transformations, while ggplot2 <span class="citation" data-cites="wickham2016">(<a href="#ref-wickham2016" role="doc-biblioref">Wickham 2016</a>)</span> offers declarative visualization grammar. Yet a gap remained: existing tools addressed <em>related</em> distortion needs but not continuous geometric fisheye lenses. This package fills that niche by formalizing an sf-native FGC radial model with controllable zone parameters, optional angular effects, automatic normalization, and safe geometry handling across points, lines, and polygons.</p>
</section>
<section id="background" class="level1">
<h1>Background</h1>
<p>Before examining the mechanics of fisheye transformations, it is important to review how R’s spatial ecosystem currently addresses the detail-versus-context tradeoff. This context clarifies why existing solutions, though valuable, do not fully address the need for continuous lens-based warping.</p>
<section id="cartograms-thematic-distortion" class="level3">
<h3 class="anchored" data-anchor-id="cartograms-thematic-distortion">Cartograms: Thematic distortion</h3>
<p>The cartogram family <span class="citation" data-cites="gastner2004">(<a href="#ref-gastner2004" role="doc-biblioref">Gastner and Newman 2004</a>)</span> intentionally distorts geographic areas to encode variables—population density reshapes regions so area becomes proportional to demographic weight (see Figure @ref(fig:plot-cart)).</p>
<div class="cell">
<div class="cell-output-display">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="paper-mapycusmaximus_files/figure-html/plot-cart-1.png" class="img-fluid figure-img" width="672"></p>
<figcaption>Cartogram example: thematic distortion changes shapes and sizes to encode population.</figcaption>
</figure>
</div>
</div>
</div>
<p>This approach fundamentally differs from focus+context methods. Cartograms substitute spatial accuracy for data encoding, often severely disrupting shapes and adjacencies. For example, a population cartogram enlarges Melbourne while shrinking Mornington, prioritizing thematic insight over geographic fidelity. In contrast, the FGC fisheye transformation preserves relative positions and topology while magnifying a user-selected spatial region rather than a data-driven variable. The use cases are distinct: cartograms address the dominance of a variable in space, whereas fisheye lenses facilitate exploration of local detail within a broader geographic context.</p>
</section>
<section id="hexagon-tile-maps-discrete-abstraction" class="level3">
<h3 class="anchored" data-anchor-id="hexagon-tile-maps-discrete-abstraction">Hexagon tile maps: Discrete abstraction</h3>
<p>Packages like <code>geogrid</code> and visualizations using <code>sf::st_make_grid()</code> replace irregular polygons with regular hexagonal or square tiles, each representing an administrative unit.</p>
<div class="cell">
<div class="cell-output-display">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="paper-mapycusmaximus_files/figure-html/geo-grid-plot-1.png" class="img-fluid figure-img" width="672"></p>
<figcaption>Victoria LGA grid assignment: tile maps abstract away precise geometry in favour of adjacency.</figcaption>
</figure>
</div>
</div>
</div>
<p>As seen in Figure @ref(fig:geo-grid-plot), tile maps <em>abstract away</em> precise geography entirely, treating space as a topology-preserving tessellation where “neighbors touch” matters more than accurate boundaries. Tile maps excel at avoiding size bias (Mildura gets equal visual weight to Yarra) and creating aesthetic, clutter-free layouts. However, they abandon continuous spatial relationships: you cannot identify precise locations, measure distances, or overlay point data meaningfully. Hexbin aggregation for point data (via <code>ggplot2::geom_hex()</code>) serves a different purpose—density estimation—rather than focus+context navigation.</p>
</section>
<section id="multi-panel-approaches-spatial-separation" class="level3">
<h3 class="anchored" data-anchor-id="multi-panel-approaches-spatial-separation">Multi-panel approaches: Spatial separation</h3>
<p>Tools like <code>cowplot::ggdraw()</code><span class="citation" data-cites="cowplot">(<a href="#ref-cowplot" role="doc-biblioref">Wilke 2025</a>)</span> create side-by-side views: one panel shows overview, another shows zoomed detail (Figure @ref(fig:cow-plot-plot)).</p>
<div class="cell">
<div class="cell-output-display">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="paper-mapycusmaximus_files/figure-html/cow-plot-plot-1.png" class="img-fluid figure-img" width="672"></p>
<figcaption>Overview with inset: separates focus from context into distinct panels.</figcaption>
</figure>
</div>
</div>
</div>
<p>These are effective for static reports but require viewers to mentally integrate separate views, and they don’t preserve the <em>embedded</em> relationship between focus and context within a single continuous geography. Futhermore, if you introduce one or more elements into the plot like filling value equal to a variable, the audience will have a hard time identify the zoomed detail.</p>
</section>
<section id="why-fgc-fisheye-offers-something-distinct" class="level3">
<h3 class="anchored" data-anchor-id="why-fgc-fisheye-offers-something-distinct">Why FGC fisheye offers something distinct</h3>
<p>None of these approaches provide <em>continuous geometric magnification within a single, topology-preserving map</em>. Cartograms distort for data, not user-chosen focus. Tile maps abstract away geography. Multi-panel tools spatially separate context. The fisheye lens keeps everything in one frame—roads bend smoothly, metropolitan detail enlarges, but you still see how the city sits within its state. It’s a geometric <em>warp</em> rather than a data-driven <em>substitution</em> or panel-based <em>separation</em>. This matters for use cases like: examining hospital networks in Melbourne while maintaining Victorian context, exploring census tracts in a metro core without losing county boundaries, or analyzing transit lines with their regional hinterland visible.</p>
<p>With this landscape established, we now turn to the technical implementation: how does the FGC transformation actually work, and how does this package make it accessible within R’s spatial workflows?</p>
</section>
</section>
<section id="implementation" class="level1">
<h1>Implementation</h1>
<div class="cell">
<div class="cell-output-display">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="paper-mapycusmaximus_files/figure-html/fgc-zones-1.png" class="img-fluid figure-img" width="672"></p>
<figcaption>The three zones of an FGC transformation. Points inside the focus (red) expand radially; points in the glue (blue) compress toward the focus boundary; context points (gold) remain fixed.</figcaption>
</figure>
</div>
</div>
</div>
<div class="cell">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Inspect diagnostics returned by fisheye_fgc()</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="fu">head</span>(transform_df[, <span class="fu">c</span>(<span class="st">"x_new"</span>, <span class="st">"y_new"</span>, <span class="st">"zone"</span>, <span class="st">"r_orig"</span>, <span class="st">"r_new"</span>)])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code># A tibble: 6 × 5
  x_new y_new zone    r_orig r_new
  &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt;    &lt;dbl&gt; &lt;dbl&gt;
1  -1      -1 context   1.41  1.41
2  -0.9    -1 context   1.35  1.35
3  -0.8    -1 context   1.28  1.28
4  -0.7    -1 context   1.22  1.22
5  -0.6    -1 context   1.17  1.17
6  -0.5    -1 context   1.12  1.12</code></pre>
</div>
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="fu">table</span>(transform_df<span class="sc">$</span>zone)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>
context   focus    glue 
    362      37      42 </code></pre>
</div>
</div>
<p>Consider a point (P = (x, y)) in a projected coordinate system. The analyst chooses a center (C = (c_x, c_y)) and two radii: (r_{}) delineating the focus region and (r_{}) marking the glue boundary. Points inside the focus magnify, points between the radii focus on the center and then compress according to a smooth curve, and points outside remain unchanged. This radial scheme keeps angular coordinates intact, thereby preserving bearings and relative direction.</p>
<section id="algorithm" class="level2">
<h2 class="anchored" data-anchor-id="algorithm">Algorithm</h2>
<p>Let <span class="math inline">\((r, \theta)\)</span> denote the polar form of point <span class="math inline">\(P = (x, y)\)</span> relative to center <span class="math inline">\(C = (c_x, c_y)\)</span>. The transformation defines a new radius <span class="math inline">\(r'\)</span> via a piecewise function:</p>
<p><span class="math display">\[\begin{equation}
r' =
\begin{cases}
   \min\left( z \cdot r, r_{\text{in}} \right) &amp; \text{if } r \le r_{\text{in}}, \\
   r_{\text{in}} + (r_{\text{out}} - r_{\text{in}}) \cdot h(u; s) &amp; \text{if } r_{\text{in}} &lt; r \le r_{\text{out}}, \\
   r &amp; \text{if } r &gt; r_{\text{out}},
\end{cases}
\end{equation}\]</span></p>
<p>where (z &gt; 1) is the zoom factor within the focus, (s (0, 1]) controls glue compression, and (u = { (r - r_{}) }/{ (r_{} - r_{}) }) normalises the glue radius to ([0,1]). The function (h(u; s)) is chosen so that (h(0; s) = 0), (h(1; s) = 1), and both the first derivatives and the radii match at the boundaries. We adopt a symmetric power curve:</p>
<p><span class="math display">\[\begin{equation}
h(u; s) =
\begin{cases}
   \tfrac{1}{2} \cdot u^{1/s} &amp; \text{if } 0 \le u \le 0.5, \\
   1 - \tfrac{1}{2} \cdot (1 - u)^{1/s} &amp; \text{if } 0.5 &lt; u \le 1,
\end{cases}
\end{equation}\]</span></p>
<p>which compresses radii near both boundaries and emphasises the mid-glue region. Analysts seeking outward compression can choose alternative methods (e.g., the <code>"outward"</code> mode) that bias the curve towards (r_{}). The demonstration on how original and transformed radius can be seen at the Figure @ref(fig:radial-curve). The transform optionally introduces rotation within the glue zone to accentuate the flow from detail to context. Let ((u)) denote the angular adjustment. We employ a bell-shaped profile: ((u) = 4u(1-u)), where () is the revolution parameter (in radians). This function peaks at the glue midpoint and vanishes at the boundaries, ensuring continuity.</p>
<div class="cell">
<div class="cell-output-display">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="paper-mapycusmaximus_files/figure-html/radial-curve-1.png" class="img-fluid figure-img" style="width:120.0%"></p>
<figcaption>Radial mapping r→r’ across focus, glue, and context.</figcaption>
</figure>
</div>
</div>
</div>
</section>
<section id="integration-with-sf" class="level2">
<h2 class="anchored" data-anchor-id="integration-with-sf">Integration with sf</h2>
<p>Spatial datasets vary widely in CRS, extent, feature types, and schemas. mapycusmaximus follows a disciplined staged workflow where each step is explicit, auditable, and invariant to input type. The architecture separates numeric mapping, spatial orchestration, and geometry reconstruction, allowing the core transform to remain small and testable while sf-specific concerns are isolated in thin wrappers.</p>
<section id="workflow-and-crs-handling" class="level3">
<h3 class="anchored" data-anchor-id="workflow-and-crs-handling">Workflow and CRS handling</h3>
<p>The pipeline proceeds: <strong>sanitize input</strong> → <strong>select working CRS</strong> → <strong>normalize</strong> → <strong>warp</strong> → <strong>denormalize</strong> → <strong>restore original CRS</strong>. Empty geometries are dropped and <code>sf::st_zm()</code> enforces 2D coordinates.</p>
<section id="crs-selection" class="level4">
<h4 class="anchored" data-anchor-id="crs-selection">CRS selection</h4>
<p>If the layer is already in a projected CRS, that CRS is used. If it is geographic (lon/lat), the data are transformed to a sensible local projected CRS (e.g., UTM inferred from the centroid; for Victoria, GDA2020/MGA55 is typical). Distances are then in metres and parameters behave consistently. The original CRS is restored on return.</p>
</section>
<section id="normalization" class="level4">
<h4 class="anchored" data-anchor-id="normalization">Normalization</h4>
<div class="cell" data-layout-align="center">
<div class="cell-output-display">
<div class="grViz html-widget html-fill-item" id="htmlwidget-cdb90690dd6cfbb977e7" style="width:100%;height:480px;"></div>
<script type="application/json" data-for="htmlwidget-cdb90690dd6cfbb977e7">{"x":{"diagram":"\ndigraph fgc {\n  rankdir=TB; nodesep=0.25; ranksep=0.4;\n  node [shape=rect, style=rounded, fontsize=10, fontname=Helvetica, fillcolor=\"#f5f5f9\", color=\"#4e4d47\", style=filled];\n  edge [color=\"#4e79a7\", arrowsize=.7];\n\n  A [label=\"Input sf/sfc or matrix\\noptions: center, preserve_aspect, normalized_center\"];\n  B [shape=diamond, label=\"Projected?\", fillcolor=\"#eef3ff\"];\n  C [label=\"Use layer CRS\"];\n  D [label=\"Transform to projected CRS\\n(UTM / GDA2020)\"];\n  E [label=\"BBox (xmin,xmax,ymin,ymax)\"];\n  F [label=\"Compute mid + half-spans\"];\n  G [shape=diamond, label=\"Preserve aspect?\", fillcolor=\"#eef3ff\"];\n  H [label=\"Use s=max(sx,sy)\"];\n  I [label=\"Use sx,sy independently\"];\n  J [shape=diamond, label=\"Resolve center\", fillcolor=\"#eef3ff\"];\n  K [label=\"sf/sfc → centroid\"];\n  L [label=\"numeric + CRS → transform\"];\n  M [label=\"numeric only → lon/lat heuristic\"];\n  N [label=\"normalized_center → (mx,my)+center*scale\"];\n  O [label=\"Normalize to unit space\"];\n  P [label=\"Apply fisheye\"];\n  Q [label=\"Denormalize\"];\n  R [label=\"Restore CRS\"];\n\n  A -> B; \n  B -> C [label=\"yes\"]; \n  B -> D [label=\"no\"];\n  C -> E; \n  D -> E; \n  E -> F; \n  F -> G;\n  G -> H [label=\"yes\"]; \n  G -> I [label=\"no\"];\n  H -> J; \n  I -> J;\n  J -> K; \n  J -> L; \n  J -> M; \n  J -> N;\n  K -> O; \n  L -> O; \n  M -> O; \n  N -> O;\n  O -> P; \n  P -> Q; \n  Q -> R;\n}\n","config":{"engine":"dot","options":null}},"evals":[],"jsHooks":[]}</script>
<p>Diagram of the normalization step</p>
</div>
</div>
<p>A bounding box defines the normalizing scale. With <code>preserve_aspect = TRUE</code>, a uniform scale <span class="math inline">\(s = \max(s_x, s_y)\)</span> is applied; otherwise axes scale independently. Center resolution happens before normalization: <code>sf</code>/<code>sfc</code> centres reduce to a centroid then transform to the working CRS; numeric pairs with <code>center_crs</code> are transformed; numeric pairs without CRS are interpreted heuristically; with <code>normalized_center = TRUE</code>, pairs live in <span class="math inline">\([-1, 1]\)</span> relative to the bbox midpoint. If no center is given, the bbox midpoint is used.</p>
</section>
</section>
<section id="core-transformation" class="level3">
<h3 class="anchored" data-anchor-id="core-transformation">Core transformation</h3>
<p>At the heart of the package is <code>fisheye_fgc()</code>, a vectorized function mapping an <span class="math inline">\(n \times 2\)</span> coordinate matrix to a new <span class="math inline">\(n \times 2\)</span> matrix via the FGC rule. Its contract is minimal: numeric arrays and scalar parameters defining center, radii, magnification, compression, method, and revolution. Internally it converts to polar form, applies the piecewise radial map with smooth boundary conditions, optionally perturbs angle via bell-shaped rotation, and converts back to Cartesian.</p>
<div class="cell">
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="paper-mapycusmaximus_files/figure-html/basic-example-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<p>It attaches diagnostic attributes (zone labels, original and new radii) consumed by plotting utilities but not affecting geometry reconstruction.</p>
<div class="cell">
<div class="cell-output cell-output-stdout">
<pre><code>     x_new y_new
[1,]  -1.0    -1
[2,]  -0.9    -1
[3,]  -0.8    -1
[4,]  -0.7    -1
[5,]  -0.6    -1
[6,]  -0.5    -1</code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] "dim"             "dimnames"        "zones"           "original_radius"
[5] "new_radius"     </code></pre>
</div>
</div>
<p>Numeric stability at zone boundaries is ensured by clamping expansions in the focus so radii do not exceed <span class="math inline">\(r_{in}\)</span>, and using smooth power curves in the glue so derivatives match across boundaries. The radial mapping is vectorized and runs in linear time in the number of vertices as seen in the benchmark @ref(fig:bench-plot).</p>
<div class="cell">
<div class="cell-output-display">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="paper-mapycusmaximus_files/figure-html/bench-plot-1.png" class="img-fluid figure-img" width="672"></p>
<figcaption>Benchmark performance of fisheye_fgc() and sf_fisheye()</figcaption>
</figure>
</div>
</div>
</div>
</section>
<section id="geometry-reconstruction" class="level3">
<h3 class="anchored" data-anchor-id="geometry-reconstruction">Geometry reconstruction</h3>
<p>At the top level is an all-in-one function <code>sf_fisheye()</code>, which presents the user-facing interface while keeping the numeric core untouched. It validates input, selects working CRS, resolves center, constructs normalization closures, and invokes <code>st_transform_custom()</code> to rebuild geometries.</p>
<p>The geometry walker <code>st_transform_custom()</code> acts as a drop-in analogue to <code>sf::st_transform()</code> but applies an arbitrary coordinate function. For each feature, it extracts coordinates via <code>sf::st_coordinates()</code>, yielding a matrix with columns <span class="math inline">\((x, y, L1, L2, \dots)\)</span> where L1 and L2 index polygon rings and multi-polygon parts. Geometries are split by type:</p>
<ul>
<li><strong>POINT</strong>: direct warp</li>
<li><strong>LINESTRING</strong>: warp each vertex, retain order<br>
</li>
<li><strong>POLYGON</strong>: process each ring (identified by L1) independently</li>
<li><strong>MULTIPOLYGON</strong>: nested by (L1, L2) combinations</li>
</ul>
<p>After transformation, polygon rings are explicitly closed by forcing first and last vertices to equality: <span class="math inline">\((x_1', y_1') = (x_n', y_n')\)</span>. This prevents numerical drift when the warp changes ring curvature. Geometries are rebuilt using sf constructors (<code>st_point()</code>, <code>st_linestring()</code>, <code>st_polygon()</code>, <code>st_multipolygon()</code>), combined into an sfc with original CRS, and spliced back into an sf if appropriate. Attributes are preserved because only the geometry column is replaced.</p>
<p>Table @ref(tab:transformation-table) illustrates coordinate transformations across zones for a vertical transect, showing radial expansion in the focus, smooth compression in the glue, and identity mapping in the context.</p>
<div class="cell">
<div class="cell-output-display">
<table class="caption-top table table-sm table-striped small">
<caption>Coordinate transformation across zones for selected points</caption>
<thead>
<tr class="header">
<th style="text-align: right;">x</th>
<th style="text-align: right;">y</th>
<th style="text-align: right;">x_new</th>
<th style="text-align: right;">y_new</th>
<th style="text-align: left;">zone</th>
<th style="text-align: right;">r_orig</th>
<th style="text-align: right;">r_new</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: right;">-1.0</td>
<td style="text-align: right;">-1</td>
<td style="text-align: right;">-1.000</td>
<td style="text-align: right;">-1.000</td>
<td style="text-align: left;">context</td>
<td style="text-align: right;">1.414</td>
<td style="text-align: right;">1.414</td>
</tr>
<tr class="even">
<td style="text-align: right;">-0.9</td>
<td style="text-align: right;">-1</td>
<td style="text-align: right;">-0.900</td>
<td style="text-align: right;">-1.000</td>
<td style="text-align: left;">context</td>
<td style="text-align: right;">1.345</td>
<td style="text-align: right;">1.345</td>
</tr>
<tr class="odd">
<td style="text-align: right;">-0.8</td>
<td style="text-align: right;">-1</td>
<td style="text-align: right;">-0.800</td>
<td style="text-align: right;">-1.000</td>
<td style="text-align: left;">context</td>
<td style="text-align: right;">1.281</td>
<td style="text-align: right;">1.281</td>
</tr>
<tr class="even">
<td style="text-align: right;">-0.7</td>
<td style="text-align: right;">-1</td>
<td style="text-align: right;">-0.108</td>
<td style="text-align: right;">-0.323</td>
<td style="text-align: left;">focus</td>
<td style="text-align: right;">0.316</td>
<td style="text-align: right;">0.340</td>
</tr>
<tr class="odd">
<td style="text-align: right;">-0.6</td>
<td style="text-align: right;">-1</td>
<td style="text-align: right;">0.000</td>
<td style="text-align: right;">-0.340</td>
<td style="text-align: left;">focus</td>
<td style="text-align: right;">0.300</td>
<td style="text-align: right;">0.340</td>
</tr>
<tr class="even">
<td style="text-align: right;">-0.5</td>
<td style="text-align: right;">-1</td>
<td style="text-align: right;">0.108</td>
<td style="text-align: right;">-0.323</td>
<td style="text-align: left;">focus</td>
<td style="text-align: right;">0.316</td>
<td style="text-align: right;">0.340</td>
</tr>
<tr class="odd">
<td style="text-align: right;">-0.4</td>
<td style="text-align: right;">-1</td>
<td style="text-align: right;">0.000</td>
<td style="text-align: right;">-0.500</td>
<td style="text-align: left;">glue</td>
<td style="text-align: right;">0.500</td>
<td style="text-align: right;">0.500</td>
</tr>
<tr class="even">
<td style="text-align: right;">-0.3</td>
<td style="text-align: right;">-1</td>
<td style="text-align: right;">-0.300</td>
<td style="text-align: right;">-0.400</td>
<td style="text-align: left;">glue</td>
<td style="text-align: right;">0.500</td>
<td style="text-align: right;">0.500</td>
</tr>
<tr class="odd">
<td style="text-align: right;">-0.2</td>
<td style="text-align: right;">-1</td>
<td style="text-align: right;">-0.200</td>
<td style="text-align: right;">-0.400</td>
<td style="text-align: left;">glue</td>
<td style="text-align: right;">0.447</td>
<td style="text-align: right;">0.448</td>
</tr>
</tbody>
</table>
</div>
</div>
</section>
<section id="design-and-extensibility" class="level3">
<h3 class="anchored" data-anchor-id="design-and-extensibility">Design and extensibility</h3>
<p>Utilities in <code>utils.R</code> provide <code>create_test_grid()</code> for diagnostics, <code>classify_zones()</code> for labeling, and <code>plot_fisheye_fgc()</code> for visualization. Dataset documentation in <code>data.R</code> accompanies example layers (vic, vic_fish, conn_fish) used in tests.</p>
<p>For multi-layer maps, the normal process is combine all the layers into a single sf object and apply <code>sf_fisheye()</code>, then split the result later. One minialist example for this approach is show in the code block below.</p>
<div class="cell" data-caption="Handling of multi-layer maps in sf_fisheye()">
<div class="sourceCode cell-code" id="cb7"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Multi-layer example</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>bind <span class="ot">&lt;-</span> dplyr<span class="sc">::</span><span class="fu">bind_rows</span>(</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>  object_1 <span class="sc">|&gt;</span> dplyr<span class="sc">::</span><span class="fu">mutate</span>(<span class="at">.layer=</span><span class="st">"object_1"</span>), </span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>  object_2 <span class="sc">|&gt;</span> dplyr<span class="sc">::</span><span class="fu">mutate</span>(<span class="at">.layer=</span><span class="st">"object_2"</span>))</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>bind_w <span class="ot">&lt;-</span> <span class="fu">sf_fisheye</span>(</span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>  bind, </span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>  <span class="at">center =</span> melb, </span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>  <span class="at">r_in =</span> <span class="fl">0.34</span>, </span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a>  <span class="at">r_out =</span> <span class="fl">0.55</span>, </span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a>  <span class="at">zoom =</span> <span class="fl">1.8</span>, </span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a>  <span class="at">squeeze =</span> <span class="fl">0.35</span>)</span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true" tabindex="-1"></a>object_1_transformed   <span class="ot">&lt;-</span> bind_w <span class="sc">|&gt;</span> </span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true" tabindex="-1"></a>  dplyr<span class="sc">::</span><span class="fu">filter</span>(.layer <span class="sc">==</span> <span class="st">"object_1"</span>) <span class="sc">|&gt;</span> </span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true" tabindex="-1"></a>  dplyr<span class="sc">::</span><span class="fu">select</span>(<span class="sc">-</span>.layer)</span>
<span id="cb7-17"><a href="#cb7-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-18"><a href="#cb7-18" aria-hidden="true" tabindex="-1"></a>object_2_transformed   <span class="ot">&lt;-</span> bind_w <span class="sc">|&gt;</span> </span>
<span id="cb7-19"><a href="#cb7-19" aria-hidden="true" tabindex="-1"></a>  dplyr<span class="sc">::</span><span class="fu">filter</span>(.layer <span class="sc">==</span> <span class="st">"object_2"</span>) <span class="sc">|&gt;</span> </span>
<span id="cb7-20"><a href="#cb7-20" aria-hidden="true" tabindex="-1"></a>  dplyr<span class="sc">::</span><span class="fu">select</span>(<span class="sc">-</span>.layer)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>The test suite mirrors the modular structure, covering boundary behaviour, zone labeling, CRS round‑trips, ring closure, and performance. Functions follow tidyverse‑oriented conventions (snake_case parameters, small exported surface). Behaviour is validated by tests; we aim for stability across versions but do not promise guarantees.</p>
</section>
</section>
<section id="parameters" class="level2">
<h2 class="anchored" data-anchor-id="parameters">Parameters</h2>
<p>The principal user interface is <code>sf_fisheye()</code>, which accepts an <code>sf</code> or <code>sfc</code> object and returns an object of the same top-level class whose geometry has been warped in a projection- aware manner. For clarity, we group arguments into data/CRS handling, centre selection, and radial warping, and we make explicit the invariants enforced by the implementation.</p>
<p><strong>Data and CRS.</strong> The argument <code>sf_obj</code> supplies the features to be transformed. Before any calculation, empty geometries are removed and Z/M dimensions are dropped using <code>sf::st_zm()</code>, so that downstream computation operates on a strict (n) coordinate matrix. The optional <code>target_crs</code> sets the working projected CRS; if provided, the input is transformed via <code>sf::st_transform()</code> and the original CRS is restored on return. When <code>target_crs = NULL</code> and the input is geographic (lon/lat), a projected working CRS is chosen deterministically from the layer’s centroid: the default value is GDA2020 /; otherwise a UTM zone is inferred by longitude and hemisphere. This choice ensures the fisheye operates in metric units with bounded distortion across the extent of interest. The <code>preserve_aspect</code> flag governs normalisation: with <code>TRUE</code> (default) a uniform scale (s = (s_x, s_y)) is applied, where (s_x, s_y) are bbox half-spans; with <code>FALSE</code>, independent scales are used per axis. Uniform scaling preserves circular symmetry of the focus and glue; per-axis scaling yields an ellipticalinterpretation that can be useful for long, narrow extents but should be used deliberately. Degenerate cases ((s_x = 0) or (s_y = 0)) are handled by substituting a unit scale to avoid division by zero.</p>
<p><strong>Centre selection.</strong> The lens centre may be specified in several forms. The preferred interface is <code>center</code>, which takes precedence over legacy <code>cx</code>, <code>cy</code>. If <code>center</code> is a numeric pair and <code>center_crs</code> is provided (e.g., <code>"EPSG:4326"</code>), the point is transformed into the working CRS. If <code>center_crs</code> is omitted, a heuristic interprets pairs that lie within (||), (||) as WGS84 and transforms them accordingly; otherwise the values are assumed to be already in working-CRS map units. Any <code>sf</code>/<code>sfc</code> geometry may be used as <code>center</code>; non-point centres are combined and reduced to a centroid and then transformed to the working CRS, which is often convenient when the focal area is a polygon (e.g., a CBD boundary) or a set of points (e.g., incident locations). Finally, when the argument <code>{normalized_center = TRUE}</code>, <code>center</code> is interpreted as a pair in ([-1,1]) relative to the bbox midpoint and the chosen normalisation (uniform or per-axis). Normalised centres make parameter sets portable across datasets of different extents and are a natural fit for parameter sweeps in reproducible pipelines. If no centre is supplied, the bbox midpoint is used; this default is stable under reprojection.</p>
<p><strong>Radial warping.</strong> The radii <code>r_in</code> and <code>r_out</code> define the focus and glue boundaries in the normalised coordinate space and must satisfy <code>r_out &gt; r_in</code>. The interpretation of these radii depends on <code>preserve_aspect</code>. With uniform scaling, a circle of radius (r_{}) in unit space corresponds to a circle of radius (r_{},s) in map units; with per-axis scaling, the corresponding shape is an axis-aligned ellipse with semi-axes (r_{}s_x) and (r_{}s_y). Inside the focus, distances from the centre are multiplied by <code>zoom_factor</code>; to prevent overshoot, the implementation clamps (r’) so that points do not cross the (r_{}) boundary. Across the glue, <code>squeeze_factor</code> in <span class="math inline">\((0,1]\)</span> controls how strongly intermediate radii compress: smaller values create tighter compression near the boundaries and a more pronounced “shoulder” in the middle of the glue; larger values approach a linear transition. The <code>method</code> selects the family of curves used in the glue. The default <code>"expand"</code> applies a symmetrical power law that expands inward and outward halves of the glue to maintain visual balance around the midpoint; <code>"outward"</code> biases the map towards (r_{}), keeping the outer boundary steadier and pushing more deformation into the inner portion of the glue. The optional <code>revolution</code> parameter adds a bell-shaped angular twist inside the glue of magnitude (,4u(1-u)), where (u) is the normalised glue radius. This rotation vanishes at both glue boundaries and peaks at the midpoint, preserving continuity. Positive values rotate counter-clockwise, negative values clockwise; values are specified in radians.</p>
<p><strong>Inter-parameter interactions and invariants.</strong> The following constraints and behaviours are enforced: (r_{} &gt; r_{} &gt; 0); <code>zoom_factor</code> () (values close to one yield gentle focus); <code>squeeze_factor</code> in ((0,1]) ((=1) approaches linear); and monotonicity of the radial map so that ordering by distance from the centre is preserved. The choice of <code>preserve_aspect</code> affects the physical size of radii and thereby the impact of a given parameter set on different datasets; using uniform scaling with a normalised centre yields the most portable configurations. Twisting via <code>revolution</code> is confined to the glue; it does not change radii and therefore does not affect the classification of points into zones. Because angles are modified only in the glue, bearings inside the focus and in the context are preserved.</p>
<p><strong>Return value and side effects.</strong> The function returns an object of the same top-level class as its input (<code>sf</code> or <code>sfc</code>). For <code>sf</code> inputs, non-geometry columns are preserved verbatim; only the geometry column is replaced. The original CRS is restored before return so that downstream plotting and analysis code does not need to change. On malformed geometries, the implementation emits a warning and returns an empty geometry of the appropriate family to preserve row count and indices. For exploratory diagnostics, the low-level <code>fisheye_fgc()</code> returns a coordinate matrix with attributes <code>"zones"</code>, <code>"original_radius"</code>, and <code>"new_radius"</code>; these can be used to plot scale curves and verify parameter effects prior to applying the transform to complex geometries.</p>
</section>
<section id="common-choices" class="level2">
<h2 class="anchored" data-anchor-id="common-choices">Common choices</h2>
<p>Although the parameter space is continuous, certain regimes recur in practice and can serve as reliable starting points. We describe these regimes and articulate the trade-offs that motivate each choice. The recommendations assume the default <code>preserve_aspect = TRUE</code>; when per-axis scaling is enabled, translate radii to semi-axes using the bbox half-spans.</p>
<p><strong>Balanced metropolitan focus within a state.</strong> A common narrative emphasises a city region while retaining a recognisable state outline. Choose (r_{}) to enclose the urban footprint (often (0.300.35)) and (r_{}) to provide a broad glue buffer ((0.550.70)). A <code>zoom_factor</code> of (510) provides visible enlargement without overwhelming the transition.</p>
<div class="cell">
<div class="cell-output-display">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="paper-mapycusmaximus_files/figure-html/zoom-factor-1.png" class="img-fluid figure-img" style="width:80.0%"></p>
<figcaption>Zoom factors for balanced metropolitan focus within a state.</figcaption>
</figure>
</div>
</div>
</div>
<p>Pair this with A <code>squeeze_factor</code> of (0.30.5), which gently compresses surroundings while maintaining smoothness. The <code>"expand"</code> method yields a balanced appearance in which the mid-glue region visibly bridges detail and context. If preserving the outer coastline or boundary is paramount (e.g., for policy maps where the edge must remain stable), <code>"outward"</code> can be substituted to reduce outer drift at the cost of slightly stronger inner squeeze.</p>
<p><strong>Dense line networks and flows.</strong> When the layer of interest is line-heavy (transport corridors, flows, hydrology), kink introduction and overplotting are the primary risks. Reduce glue compression and avoid large twists: <code>squeeze_factor \ge 0.35</code> (ideally (0.400.60)) coupled with <code>revolution \le 0.2</code> radians keeps linework legible while still communicating focus. The <code>"expand"</code> method is generally preferable because its symmetric treatment of the glue reduces inflections near (r_{}) and (r_{}). When in doubt, plot a radius-vs-radius diagnostic from <code>fisheye_fgc()</code> to confirm that the derivative remains near one at boundaries.</p>
<p><strong>Polygon-dominated maps and choropleths.</strong> For administrative regions, land-use parcels, or other polygon-dense layers, slightly stronger compression in the glue is tolerable because viewers rely on silhouette and adjacency rather than precise edge angles. Settings such as <code>{squeeze_factor = 0.25\text{ - }0.40}</code> with <code>zoom_factor = 5\text{ - }20}</code> and either <code>"expand"</code> or <code>"outward"</code> often work well.</p>
<div class="cell">
<div class="cell-output-display">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="paper-mapycusmaximus_files/figure-html/method-plot-1.png" class="img-fluid figure-img" width="672"></p>
<figcaption>Different method for glue compression</figcaption>
</figure>
</div>
</div>
</div>
<p>We recommend <code>revolution = 0</code> for publication unless the swirl is part of the intended rhetoric; twists, while visually engaging, can distract from choropleth encoding and complicate legend interpretation.</p>
<p><strong>Small multiples and parameter sweeps.</strong> Analysts frequently compare scenarios across maps (e.g., different thresholds or temporal slices). Portability of parameters is maximised by using a normalised centre (<code>normalized_center = TRUE</code>) with <code>preserve_aspect = TRUE</code>. This yields consistent radii across datasets of different extent and makes small multiples directly comparable.</p>
<p>A pattern that works well is to fix (r_{}, r_{}) and <code>squeeze_factor</code>, and vary <code>zoom_factor</code> over a short range (e.g., (1.3, 1.6, 2.0)). Faceting these outputs produces a transparent narrative of how emphasis changes with magnification.</p>
<p><strong>Choosing radii from map scale.</strong> When stakeholders communicate distances in kilometres or miles, convert desired physical radii to unit radii using the bbox half-span. With <code>{preserve_aspect = TRUE}</code>, (r_{} = d/s) where (d) is the intended focus radius in map units (metres for metric projections) and (s) is the larger half-span of the bbox.</p>
<div class="cell" data-layout-align="center">
<div class="cell-output-display">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="paper-mapycusmaximus_files/figure-html/radii-prepare-1.png" class="img-fluid figure-img" style="width:100.0%"></p>
<figcaption>Map scale for different radii</figcaption>
</figure>
</div>
</div>
<div class="cell-output-display">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="paper-mapycusmaximus_files/figure-html/radii-prepare-2.png" class="img-fluid figure-img" style="width:100.0%"></p>
<figcaption>Map scale for different radii</figcaption>
</figure>
</div>
</div>
</div>
<p>This rule allows quick calibration: for a state with half-span 250 km, a desired 75 km focus corresponds to (r_{} ). For per-axis scaling, choose semi-axes independently: (r_{} = d_x/s_x), (r_{} = d_y/s_y), noting that the current implementation interprets (r_{}) as a single scalar and therefore realises an ellipse only through <code>preserve_aspect = FALSE</code>.</p>
<p><strong>Centres for reproducibility.</strong> To avoid ambiguity in collaborative settings, prefer specifying <code>center</code> either as an <code>sf</code> geometry (whose CRS is explicit) or as a lon/lat pair with <code>center_crs = "EPSG:4326"</code>. Numeric pairs without CRS are accepted but rely on heuristics. When the focal area is itself a polygon or multi-polygon, passing that object as <code>center</code> ensures the centroid is derived from the same dataset used for the map, improving reproducibility and intent.</p>
<p><strong>CRS considerations.</strong> Leaving <code>target_crs = NULL</code> suffices for most lon/lat inputs because the working CRS is chosen deterministically. Projects that maintain a standard grid (e.g., local government dashboards) should specify <code>target_crs</code> to improve cross-report comparability. Avoid switching working CRS between layers that will be overlaid; doing so changes the meaning of normalised radii and will misalign warps.</p>
<p><strong>Publication vs.&nbsp;exploration.</strong> For exploratory notebooks and talks, small nonzero <code>revolution</code> values (() radians) can help audiences perceive continuity across the glue.</p>
<div class="cell" data-layout-align="center">
<div class="cell-output-display">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="paper-mapycusmaximus_files/figure-html/fisheye-revolution-1.png" class="img-fluid figure-img" width="672"></p>
<figcaption>Fisheye with different revolutions.</figcaption>
</figure>
</div>
</div>
</div>
<p>For manuscripts and dashboards, prefer <code>revolution = 0</code>. Similarly, start with <code>"expand"</code> and adopt <code>"outward"</code> only when outer stability is an explicit requirement. Always annotate or at least describe the distortion in figure captions so readers do not mistake warped areas for standard projections.</p>
</section>
</section>
<section id="examples-of-use" class="level1">
<h1>Examples of use</h1>
<p>We present the applied scenario to illustrate how the FGC fisheye clarifies local structure while retaining geographic context. We will uses Victorian hospital-RACF to demonstrate overplotting relief and alignment across multiple layers.</p>
<div class="cell">
<div class="cell-output-display">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="paper-mapycusmaximus_files/figure-html/hospitals-basic-plot-1.png" class="img-fluid figure-img" width="672"></p>
<figcaption>Standard maps: hospital (red) and RACF (blue) points plotted over Victoria without fisheye.</figcaption>
</figure>
</div>
</div>
</div>
<p>As shown in Figure @ref(fig:hospitals-basic-plot), standard maps of hospital and RACF locations quickly become cluttered in metropolitan Melbourne. Points occlude one another, and the relationship between facilities is difficult to assess. The simple pair of small-scale views indicates relative counts (many RACFs, fewer hospitals) but masks local proximity patterns and neighbourhood coverage.</p>
<div class="cell">
<div class="cell-output-display">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="paper-mapycusmaximus_files/figure-html/fisheye-plot-1.png" class="img-fluid figure-img" width="672"></p>
<figcaption>Fisheye applied with a common centre and parameters keeps overlays aligned while magnifying the Melbourne LGA.</figcaption>
</figure>
</div>
</div>
</div>
<p>Applying the fisheye to both features (points) and boundaries with a common centre (the MELBOURNE polygon) and shared parameters (<code>zoom = 20</code>, <code>squeeze = 0.3</code>, method = “expand”) yields a single, continuous map in which the Melbourne LGA is magnified while the rest of Victoria remains readable. Because all layers undergo the same warp, overlays remain aligned. The result improves visual separation of facilities and reveals local hub structures without resorting to insets. All computations on attributes remain valid—the geometry is warped for display, but feature identity, CRS metadata, and table structure are preserved. As with any lens, distances and areas inside the focus and glue are not metric and should not be used for quantitative spatial inference.</p>
</section>
<section id="discussion" class="level1">
<h1>Discussion</h1>
<p><strong>Contribution</strong> mapycusmaximus provides an sf‑native implementation of the FGC fisheye that is projection‑aware, parameterised in normalised units, and safe across points, lines, and polygons. The package separates radial mapping from geometry orchestration, exposes explicit controls over focus, glue, and context, and preserves attributes and CRS invariants for reproducible pipelines with ggplot2.</p>
<p><strong>Relation to alternatives</strong> Unlike cartograms (thematic distortion), hex/regular tile maps (discrete abstraction), or inset/multi‑panel layouts (spatial separation), the FGC lens delivers continuous magnification within a single map while preserving topology and bearings. This reduces cognitive load for readers who must relate local phenomena to their broader geography.</p>
<p><strong>Limitations</strong> The fisheye introduces non‑metric distortion in the focus and glue; therefore, use it for visual exploration and communication, not for metric analysis. Aggressive <code>zoom</code> or <code>squeeze</code> can impair legibility near the glue boundary; conservative defaults and <code>revolution = 0</code> are recommended for publication maps. When comparing multiple regions, prefer <code>normalized_center = TRUE</code> with fixed radii to ensure visual comparability. At present, exact matching of focus and glue radii across separately transformed layers may require a manual step (the user have to manually merge the two or more layers, perform the fisheye transformation, then seperated the transformed layers).</p>
<p><strong>Future work</strong> Planned extensions include anisotropic or elliptical profiles, multi‑focus blending, first‑class raster support via warped grids and resampling, and interactive focus selection for exploratory analysis. We also plan an API for shared normalisation and radius locking across layers (e.g., a <code>combine_fisheye</code>) so that multiple layers can be warped with identical scale and then returned transformed. Performance improvements via vectorised geometry walkers or GPU acceleration would benefit dense polygonal datasets. Clear figure captions and scale disclaimers remain essential to communicate the presence and intent of distortion.</p>
</section>
<section id="conclusion" class="level1">
<h1>Conclusion</h1>
<p>FGC fisheye transformations offer a concise, CRS‑aware way to emphasise local structure without losing geographic context. By starting from a point‑wise radial map and integrating carefully with sf for geometry reconstruction, the approach keeps figures continuous and overlays aligned. The examples demonstrate clearer narratives for metropolitan focus while maintaining state‑ or nation‑level context.</p>
</section>
<section id="ai-use-declaration" class="level1">
<h1>AI Use Declaration</h1>
<p>We used AI tools to assist with code refactoring and drafting portions of the text. All methods, parameter settings, and claims were designed and reviewed by the authors, and we verified outputs with the package’s test suite and example renders.</p>
</section>
<section id="resources" class="level1">
<h1>Resources</h1>
<p>The github link for this paper is <a href="https://github.com/Alex-Nguyen-VN/paper-mapycusmaximus">here</a>.</p>
<p>The mapycusmaximus package is available on <a href="https://github.com/Alex-Nguyen-VN/mapycusmaximus">GitHub</a>.</p>
<p>The slideshow for this package can be found <a href="https://github.com/Alex-Nguyen-VN/Talk/tree/main/mapycus-slide">here</a>.</p>

</section>

<div id="quarto-appendix" class="default"><section class="quarto-appendix-contents" role="doc-bibliography" id="quarto-bibliography"><h2 class="anchored quarto-appendix-heading">References</h2><div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list">
<div id="ref-bier1993" class="csl-entry" role="listitem">
Bier, Eric A., Maureen C. Stone, Ken Pier, William Buxton, and Tony D. DeRose. 1993. <span>“Toolglass and Magic Lenses: The See-Through Interface.”</span> In <em>Proceedings of SIGGRAPH ’93</em>, 73–80. <a href="https://doi.org/10.1145/166117.166126">https://doi.org/10.1145/166117.166126</a>.
</div>
<div id="ref-carpendale2001" class="csl-entry" role="listitem">
Carpendale, M. Sheelagh T., and Catherine Montagnese. 2001. <span>“A Framework for Unifying Presentation Space.”</span> In <em>Proceedings of the 14th Annual ACM Symposium on User Interface Software and Technology</em>, 61–70. <a href="https://doi.org/10.1145/502348.502371">https://doi.org/10.1145/502348.502371</a>.
</div>
<div id="ref-cockburn2008" class="csl-entry" role="listitem">
Cockburn, Andy, Amy Karlson, and Benjamin B. Bederson. 2008. <span>“A Review of Overview+detail, Zooming, and Focus+context Interfaces.”</span> <em>ACM Computing Surveys</em> 41 (1): 1–31. <a href="https://doi.org/10.1145/1456650.1456652">https://doi.org/10.1145/1456650.1456652</a>.
</div>
<div id="ref-furnas1986" class="csl-entry" role="listitem">
Furnas, George W. 1986. <span>“Generalized Fisheye Views.”</span> In <em>Proceedings of CHI ’86</em>, 16–23. <a href="https://doi.org/10.1145/22627.22342">https://doi.org/10.1145/22627.22342</a>.
</div>
<div id="ref-gastner2004" class="csl-entry" role="listitem">
Gastner, Michael T., and M. E. J. Newman. 2004. <span>“Diffusion-Based Method for Producing Density-Equalizing Maps.”</span> <em>Proceedings of the National Academy of Sciences</em> 101 (20): 7499–7504. <a href="https://doi.org/10.1073/pnas.0400280101">https://doi.org/10.1073/pnas.0400280101</a>.
</div>
<div id="ref-harrie2002" class="csl-entry" role="listitem">
Harrie, Lars, L. Tiina Sarjakoski, and Lassi Lehto. 2002. <span>“A Variable-Scale Map for Small-Display Cartography.”</span> In <em>Joint International Symposium on Geospatial Theory, Processing and Applications</em>, 1–6.
</div>
<div id="ref-lamping1995" class="csl-entry" role="listitem">
Lamping, John, Ramana Rao, and Peter Pirolli. 1995. <span>“A Focus+context Technique Based on Hyperbolic Geometry for Visualizing Large Hierarchies.”</span> In <em>Proceedings of CHI ’95</em>, 401–8. <a href="https://doi.org/10.1145/223904.223956">https://doi.org/10.1145/223904.223956</a>.
</div>
<div id="ref-RJ-2018-009" class="csl-entry" role="listitem">
Pebesma, Edzer. 2018. <span>“Simple Features for r: Standardized Support for Spatial Vector Data.”</span> <em>The R Journal</em> 10: 439–46. <a href="https://doi.org/10.32614/RJ-2018-009">https://doi.org/10.32614/RJ-2018-009</a>.
</div>
<div id="ref-sarkar1992" class="csl-entry" role="listitem">
Sarkar, Manojit, and Marc H. Brown. 1992. <span>“Graphical Fisheye Views of Graphs.”</span> In <em>Proceedings of CHI ’92</em>, 83–91. <a href="https://doi.org/10.1145/142750.142763">https://doi.org/10.1145/142750.142763</a>.
</div>
<div id="ref-sarkar1994" class="csl-entry" role="listitem">
———. 1994. <span>“Graphical Fisheye Views.”</span> <em>Communications of the ACM</em> 37 (12): 73–84. <a href="https://doi.org/10.1145/198366.198384">https://doi.org/10.1145/198366.198384</a>.
</div>
<div id="ref-snyder1987" class="csl-entry" role="listitem">
Snyder, John P. 1987. <span>“"Magnifying-Glass" Azimuthal Map Projections.”</span> <em>The American Cartographer</em> 14 (1): 61–68.
</div>
<div id="ref-wickham2016" class="csl-entry" role="listitem">
Wickham, Hadley. 2016. <em>Ggplot2: Elegant Graphics for Data Analysis</em>. Springer. <a href="https://doi.org/10.1007/978-3-319-24277-4">https://doi.org/10.1007/978-3-319-24277-4</a>.
</div>
<div id="ref-cowplot" class="csl-entry" role="listitem">
Wilke, Claus O. 2025. <em>Cowplot: Streamlined Plot Theme and Plot Annotations for ’Ggplot2’</em>. <a href="https://wilkelab.org/cowplot/">https://wilkelab.org/cowplot/</a>.
</div>
<div id="ref-yamamoto2009" class="csl-entry" role="listitem">
Yamamoto, Daisuke, Shotaro Ozeki, and Naohisa Takahashi. 2009. <span>“Wired Fisheye Lens: A Motion-Based Improved Fisheye Interface for Mobile Web Map Services.”</span> In <em>Web and Wireless Geographical Information Systems</em>, edited by A. Stewart Carswell James D.and Fotheringham and Gavin McArdle, 153–70. Berlin, Heidelberg: Springer Berlin Heidelberg. https://doi.org/<a href="https://doi.org/10.1007/978-3-642-10601-9_11">https://doi.org/10.1007/978-3-642-10601-9_11</a>.
</div>
<div id="ref-yamamoto2012" class="csl-entry" role="listitem">
Yamamoto, Daisuke, Shunsuke Ozeki, Naohisa Takahashi, and Shigeo Takahashi. 2012. <span>“A Fusion of Multiple Focuses on a Focus+glue+context Map.”</span> In <em>Advances in Cartography and GIScience</em>, 23–37. <a href="https://doi.org/10.1007/978-3-642-29934-6_2">https://doi.org/10.1007/978-3-642-29934-6_2</a>.
</div>
</div></section></div></main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>